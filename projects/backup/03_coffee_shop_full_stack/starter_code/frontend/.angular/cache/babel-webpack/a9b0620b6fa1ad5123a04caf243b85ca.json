{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/debasisbehera/Desktop/Learning/Udacity/FSND/projects/03_coffee_shop_full_stack/starter_code/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _get from \"/Users/debasisbehera/Desktop/Learning/Udacity/FSND/projects/03_coffee_shop_full_stack/starter_code/frontend/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/debasisbehera/Desktop/Learning/Udacity/FSND/projects/03_coffee_shop_full_stack/starter_code/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/debasisbehera/Desktop/Learning/Udacity/FSND/projects/03_coffee_shop_full_stack/starter_code/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/debasisbehera/Desktop/Learning/Udacity/FSND/projects/03_coffee_shop_full_stack/starter_code/frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/debasisbehera/Desktop/Learning/Udacity/FSND/projects/03_coffee_shop_full_stack/starter_code/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/debasisbehera/Desktop/Learning/Udacity/FSND/projects/03_coffee_shop_full_stack/starter_code/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _regeneratorRuntime from \"/Users/debasisbehera/Desktop/Learning/Udacity/FSND/projects/03_coffee_shop_full_stack/starter_code/frontend/node_modules/@babel/runtime/regenerator\";\nimport { __decorate, __param, __awaiter } from 'tslib';\nimport { HostListener, Injector, ElementRef, Directive, Inject, NgZone, ɵɵdefineInjectable, ɵɵinject, Injectable, Optional, ChangeDetectorRef, Component, ChangeDetectionStrategy, InjectionToken, ApplicationRef, EventEmitter, ViewContainerRef, ComponentFactoryResolver, Attribute, SkipSelf, Output, ViewChild, ContentChild, TemplateRef, IterableDiffers, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { NgControl, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DOCUMENT, Location, LocationStrategy, CommonModule } from '@angular/common';\nimport { NavigationStart, UrlSerializer, Router, PRIMARY_OUTLET, ActivatedRoute, ChildrenOutletContexts, RouterLink } from '@angular/router';\nimport { isPlatform, getPlatforms, LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, componentOnReady, actionSheetController, alertController, loadingController, menuController, pickerController, modalController, popoverController, toastController, createAnimation, getTimeGivenProgression, createGesture, setupConfig } from '@ionic/core';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/router';\nvar _c0 = [\"*\"];\nvar _c1 = [\"outlet\"];\nvar _c2 = [[[\"\", \"slot\", \"top\"]], \"*\"];\nvar _c3 = [\"[slot=top]\", \"*\"];\nexport { IonicSafeString, IonicSwiper, createAnimation, getPlatforms, iosTransitionAnimation, isPlatform, mdTransitionAnimation } from '@ionic/core';\nimport { Subject, fromEvent, BehaviorSubject } from 'rxjs';\nimport { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';\nimport { applyPolyfills, defineCustomElements } from '@ionic/core/loader';\n\nvar raf = function raf(h) {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n\n  return setTimeout(h);\n};\n\nvar ValueAccessor = /*#__PURE__*/(function () {\n  var ValueAccessor = /*#__PURE__*/function () {\n    function ValueAccessor(injector, el) {\n      _classCallCheck(this, ValueAccessor);\n\n      this.injector = injector;\n      this.el = el;\n\n      this.onChange = function () {};\n\n      this.onTouched = function () {};\n    }\n\n    _createClass(ValueAccessor, [{\n      key: \"writeValue\",\n      value: function writeValue(value) {\n        /**\n         * TODO for Ionic 6:\n         * Change `value == null ? '' : value;`\n         * to `value`. This was a fix for IE9, but IE9\n         * is no longer supported; however, this change\n         * is potentially a breaking change\n         */\n        this.el.nativeElement.value = this.lastValue = value == null ? '' : value;\n        setIonicClasses(this.el);\n      }\n    }, {\n      key: \"handleChangeEvent\",\n      value: function handleChangeEvent(el, value) {\n        if (el === this.el.nativeElement) {\n          if (value !== this.lastValue) {\n            this.lastValue = value;\n            this.onChange(value);\n          }\n\n          setIonicClasses(this.el);\n        }\n      }\n    }, {\n      key: \"_handleBlurEvent\",\n      value: function _handleBlurEvent(el) {\n        if (el === this.el.nativeElement) {\n          this.onTouched();\n          setIonicClasses(this.el);\n        }\n      }\n    }, {\n      key: \"registerOnChange\",\n      value: function registerOnChange(fn) {\n        this.onChange = fn;\n      }\n    }, {\n      key: \"registerOnTouched\",\n      value: function registerOnTouched(fn) {\n        this.onTouched = fn;\n      }\n    }, {\n      key: \"setDisabledState\",\n      value: function setDisabledState(isDisabled) {\n        this.el.nativeElement.disabled = isDisabled;\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.statusChanges) {\n          this.statusChanges.unsubscribe();\n        }\n      }\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this = this;\n\n        var ngControl;\n\n        try {\n          ngControl = this.injector.get(NgControl);\n        } catch (\n        /* No FormControl or ngModel binding */\n        _a) {\n          /* No FormControl or ngModel binding */\n        }\n\n        if (!ngControl) {\n          return;\n        } // Listen for changes in validity, disabled, or pending states\n\n\n        if (ngControl.statusChanges) {\n          this.statusChanges = ngControl.statusChanges.subscribe(function () {\n            return setIonicClasses(_this.el);\n          });\n        }\n        /**\n         * TODO Remove this in favor of https://github.com/angular/angular/issues/10887\n         * whenever it is implemented. Currently, Ionic's form status classes\n         * do not react to changes when developers manually call\n         * Angular form control methods such as markAsTouched.\n         * This results in Ionic's form status classes being out\n         * of sync with the ng form status classes.\n         * This patches the methods to manually sync\n         * the classes until this feature is implemented in Angular.\n         */\n\n\n        var formControl = ngControl.control;\n\n        if (formControl) {\n          var methodsToPatch = ['markAsTouched', 'markAllAsTouched', 'markAsUntouched', 'markAsDirty', 'markAsPristine'];\n          methodsToPatch.forEach(function (method) {\n            if (formControl[method]) {\n              var oldFn = formControl[method].bind(formControl);\n\n              formControl[method] = function () {\n                oldFn.apply(void 0, arguments);\n                setIonicClasses(_this.el);\n              };\n            }\n          });\n        }\n      }\n    }]);\n\n    return ValueAccessor;\n  }();\n\n  ValueAccessor.ɵfac = function ValueAccessor_Factory(t) {\n    ɵngcc0.ɵɵinvalidFactory();\n  };\n\n  ValueAccessor.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ValueAccessor,\n    hostBindings: function ValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"ionBlur\", function ValueAccessor_ionBlur_HostBindingHandler($event) {\n          return ctx._handleBlurEvent($event.target);\n        });\n      }\n    }\n  });\n\n  __decorate([HostListener('ionBlur', ['$event.target'])], ValueAccessor.prototype, \"_handleBlurEvent\", null);\n\n  return ValueAccessor;\n})();\n\nvar setIonicClasses = function setIonicClasses(element) {\n  raf(function () {\n    var input = element.nativeElement;\n    var classes = getClasses(input);\n    setClasses(input, classes);\n    var item = input.closest('ion-item');\n\n    if (item) {\n      setClasses(item, classes);\n    }\n  });\n};\n\nvar getClasses = function getClasses(element) {\n  var classList = element.classList;\n  var classes = [];\n\n  for (var i = 0; i < classList.length; i++) {\n    var item = classList.item(i);\n\n    if (item !== null && startsWith(item, 'ng-')) {\n      classes.push(\"ion-\".concat(item.substr(3)));\n    }\n  }\n\n  return classes;\n};\n\nvar ɵ0 = getClasses;\n\nvar setClasses = function setClasses(element, classes) {\n  var classList = element.classList;\n  ['ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine'].forEach(function (c) {\n    return classList.remove(c);\n  });\n  classes.forEach(function (c) {\n    return classList.add(c);\n  });\n};\n\nvar ɵ1 = setClasses;\n\nvar startsWith = function startsWith(input, search) {\n  return input.substr(0, search.length) === search;\n};\n\nvar ɵ2 = startsWith;\nvar BooleanValueAccessor_1;\n\nvar BooleanValueAccessor = BooleanValueAccessor_1 = /*#__PURE__*/function (_ValueAccessor) {\n  _inherits(BooleanValueAccessor, _ValueAccessor);\n\n  var _super = _createSuper(BooleanValueAccessor);\n\n  function BooleanValueAccessor(injector, el) {\n    _classCallCheck(this, BooleanValueAccessor);\n\n    return _super.call(this, injector, el);\n  }\n\n  _createClass(BooleanValueAccessor, [{\n    key: \"writeValue\",\n    value: function writeValue(value) {\n      this.el.nativeElement.checked = this.lastValue = value == null ? false : value;\n      setIonicClasses(this.el);\n    }\n  }, {\n    key: \"_handleIonChange\",\n    value: function _handleIonChange(el) {\n      this.handleChangeEvent(el, el.checked);\n    }\n  }]);\n\n  return BooleanValueAccessor;\n}(ValueAccessor);\n\nBooleanValueAccessor.ɵfac = function BooleanValueAccessor_Factory(t) {\n  return new (t || BooleanValueAccessor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n};\n\nBooleanValueAccessor.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: BooleanValueAccessor,\n  selectors: [[\"ion-checkbox\"], [\"ion-toggle\"]],\n  hostBindings: function BooleanValueAccessor_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"ionChange\", function BooleanValueAccessor_ionChange_HostBindingHandler($event) {\n        return ctx._handleIonChange($event.target);\n      });\n    }\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: BooleanValueAccessor_1,\n    multi: true\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n\nBooleanValueAccessor.ctorParameters = function () {\n  return [{\n    type: Injector\n  }, {\n    type: ElementRef\n  }];\n};\n\n__decorate([HostListener('ionChange', ['$event.target'])], BooleanValueAccessor.prototype, \"_handleIonChange\", null);\n\nvar NumericValueAccessor_1;\n\nvar NumericValueAccessor = NumericValueAccessor_1 = /*#__PURE__*/function (_ValueAccessor2) {\n  _inherits(NumericValueAccessor, _ValueAccessor2);\n\n  var _super2 = _createSuper(NumericValueAccessor);\n\n  function NumericValueAccessor(injector, el) {\n    _classCallCheck(this, NumericValueAccessor);\n\n    return _super2.call(this, injector, el);\n  }\n\n  _createClass(NumericValueAccessor, [{\n    key: \"_handleIonChange\",\n    value: function _handleIonChange(el) {\n      this.handleChangeEvent(el, el.value);\n    }\n  }, {\n    key: \"registerOnChange\",\n    value: function registerOnChange(fn) {\n      _get(_getPrototypeOf(NumericValueAccessor.prototype), \"registerOnChange\", this).call(this, function (value) {\n        fn(value === '' ? null : parseFloat(value));\n      });\n    }\n  }]);\n\n  return NumericValueAccessor;\n}(ValueAccessor);\n\nNumericValueAccessor.ɵfac = function NumericValueAccessor_Factory(t) {\n  return new (t || NumericValueAccessor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n};\n\nNumericValueAccessor.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: NumericValueAccessor,\n  selectors: [[\"ion-input\", \"type\", \"number\"]],\n  hostBindings: function NumericValueAccessor_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"ionChange\", function NumericValueAccessor_ionChange_HostBindingHandler($event) {\n        return ctx._handleIonChange($event.target);\n      });\n    }\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: NumericValueAccessor_1,\n    multi: true\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n\nNumericValueAccessor.ctorParameters = function () {\n  return [{\n    type: Injector\n  }, {\n    type: ElementRef\n  }];\n};\n\n__decorate([HostListener('ionChange', ['$event.target'])], NumericValueAccessor.prototype, \"_handleIonChange\", null);\n\nvar RadioValueAccessor_1;\n\nvar RadioValueAccessor = RadioValueAccessor_1 = /*#__PURE__*/function (_ValueAccessor3) {\n  _inherits(RadioValueAccessor, _ValueAccessor3);\n\n  var _super3 = _createSuper(RadioValueAccessor);\n\n  function RadioValueAccessor(injector, el) {\n    _classCallCheck(this, RadioValueAccessor);\n\n    return _super3.call(this, injector, el);\n  }\n\n  _createClass(RadioValueAccessor, [{\n    key: \"_handleIonSelect\",\n    value: function _handleIonSelect(el) {\n      this.handleChangeEvent(el, el.checked);\n    }\n  }]);\n\n  return RadioValueAccessor;\n}(ValueAccessor);\n\nRadioValueAccessor.ɵfac = function RadioValueAccessor_Factory(t) {\n  return new (t || RadioValueAccessor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n};\n\nRadioValueAccessor.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: RadioValueAccessor,\n  selectors: [[\"ion-radio\"]],\n  hostBindings: function RadioValueAccessor_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"ionSelect\", function RadioValueAccessor_ionSelect_HostBindingHandler($event) {\n        return ctx._handleIonSelect($event.target);\n      });\n    }\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: RadioValueAccessor_1,\n    multi: true\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n\nRadioValueAccessor.ctorParameters = function () {\n  return [{\n    type: Injector\n  }, {\n    type: ElementRef\n  }];\n};\n\n__decorate([HostListener('ionSelect', ['$event.target'])], RadioValueAccessor.prototype, \"_handleIonSelect\", null);\n\nvar SelectValueAccessor_1;\n\nvar SelectValueAccessor = SelectValueAccessor_1 = /*#__PURE__*/function (_ValueAccessor4) {\n  _inherits(SelectValueAccessor, _ValueAccessor4);\n\n  var _super4 = _createSuper(SelectValueAccessor);\n\n  function SelectValueAccessor(injector, el) {\n    _classCallCheck(this, SelectValueAccessor);\n\n    return _super4.call(this, injector, el);\n  }\n\n  _createClass(SelectValueAccessor, [{\n    key: \"_handleChangeEvent\",\n    value: function _handleChangeEvent(el) {\n      this.handleChangeEvent(el, el.value);\n    }\n  }]);\n\n  return SelectValueAccessor;\n}(ValueAccessor);\n\nSelectValueAccessor.ɵfac = function SelectValueAccessor_Factory(t) {\n  return new (t || SelectValueAccessor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n};\n\nSelectValueAccessor.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: SelectValueAccessor,\n  selectors: [[\"ion-range\"], [\"ion-select\"], [\"ion-radio-group\"], [\"ion-segment\"], [\"ion-datetime\"]],\n  hostBindings: function SelectValueAccessor_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"ionChange\", function SelectValueAccessor_ionChange_HostBindingHandler($event) {\n        return ctx._handleChangeEvent($event.target);\n      });\n    }\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: SelectValueAccessor_1,\n    multi: true\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n\nSelectValueAccessor.ctorParameters = function () {\n  return [{\n    type: Injector\n  }, {\n    type: ElementRef\n  }];\n};\n\n__decorate([HostListener('ionChange', ['$event.target'])], SelectValueAccessor.prototype, \"_handleChangeEvent\", null);\n\nvar TextValueAccessor_1;\n\nvar TextValueAccessor = TextValueAccessor_1 = /*#__PURE__*/function (_ValueAccessor5) {\n  _inherits(TextValueAccessor, _ValueAccessor5);\n\n  var _super5 = _createSuper(TextValueAccessor);\n\n  function TextValueAccessor(injector, el) {\n    _classCallCheck(this, TextValueAccessor);\n\n    return _super5.call(this, injector, el);\n  }\n\n  _createClass(TextValueAccessor, [{\n    key: \"_handleInputEvent\",\n    value: function _handleInputEvent(el) {\n      this.handleChangeEvent(el, el.value);\n    }\n  }]);\n\n  return TextValueAccessor;\n}(ValueAccessor);\n\nTextValueAccessor.ɵfac = function TextValueAccessor_Factory(t) {\n  return new (t || TextValueAccessor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n};\n\nTextValueAccessor.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: TextValueAccessor,\n  selectors: [[\"ion-input\", 3, \"type\", \"number\"], [\"ion-textarea\"], [\"ion-searchbar\"]],\n  hostBindings: function TextValueAccessor_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"ionChange\", function TextValueAccessor_ionChange_HostBindingHandler($event) {\n        return ctx._handleInputEvent($event.target);\n      });\n    }\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: TextValueAccessor_1,\n    multi: true\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n\nTextValueAccessor.ctorParameters = function () {\n  return [{\n    type: Injector\n  }, {\n    type: ElementRef\n  }];\n};\n\n__decorate([HostListener('ionChange', ['$event.target'])], TextValueAccessor.prototype, \"_handleInputEvent\", null);\n\nvar Platform = /*#__PURE__*/function () {\n  function Platform(doc, zone) {\n    var _this2 = this;\n\n    _classCallCheck(this, Platform);\n\n    this.doc = doc;\n    /**\n     * @hidden\n     */\n\n    this.backButton = new Subject();\n    /**\n     * The keyboardDidShow event emits when the\n     * on-screen keyboard is presented.\n     */\n\n    this.keyboardDidShow = new Subject();\n    /**\n     * The keyboardDidHide event emits when the\n     * on-screen keyboard is hidden.\n     */\n\n    this.keyboardDidHide = new Subject();\n    /**\n     * The pause event emits when the native platform puts the application\n     * into the background, typically when the user switches to a different\n     * application. This event would emit when a Cordova app is put into\n     * the background, however, it would not fire on a standard web browser.\n     */\n\n    this.pause = new Subject();\n    /**\n     * The resume event emits when the native platform pulls the application\n     * out from the background. This event would emit when a Cordova app comes\n     * out from the background, however, it would not fire on a standard web browser.\n     */\n\n    this.resume = new Subject();\n    /**\n     * The resize event emits when the browser window has changed dimensions. This\n     * could be from a browser window being physically resized, or from a device\n     * changing orientation.\n     */\n\n    this.resize = new Subject();\n    zone.run(function () {\n      _this2.win = doc.defaultView;\n\n      _this2.backButton.subscribeWithPriority = function (priority, callback) {\n        return this.subscribe(function (ev) {\n          return ev.register(priority, function (processNextHandler) {\n            return zone.run(function () {\n              return callback(processNextHandler);\n            });\n          });\n        });\n      };\n\n      proxyEvent(_this2.pause, doc, 'pause');\n      proxyEvent(_this2.resume, doc, 'resume');\n      proxyEvent(_this2.backButton, doc, 'ionBackButton');\n      proxyEvent(_this2.resize, _this2.win, 'resize');\n      proxyEvent(_this2.keyboardDidShow, _this2.win, 'ionKeyboardDidShow');\n      proxyEvent(_this2.keyboardDidHide, _this2.win, 'ionKeyboardDidHide');\n      var readyResolve;\n      _this2._readyPromise = new Promise(function (res) {\n        readyResolve = res;\n      });\n\n      if (_this2.win && _this2.win['cordova']) {\n        doc.addEventListener('deviceready', function () {\n          readyResolve('cordova');\n        }, {\n          once: true\n        });\n      } else {\n        readyResolve('dom');\n      }\n    });\n  }\n  /**\n   * @returns returns true/false based on platform.\n   * @description\n   * Depending on the platform the user is on, `is(platformName)` will\n   * return `true` or `false`. Note that the same app can return `true`\n   * for more than one platform name. For example, an app running from\n   * an iPad would return `true` for the platform names: `mobile`,\n   * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n   * from Cordova then `cordova` would be true, and if it was running\n   * from a web browser on the iPad then `mobileweb` would be `true`.\n   *\n   * ```\n   * import { Platform } from 'ionic-angular';\n   *\n   * @Component({...})\n   * export MyPage {\n   *   constructor(public platform: Platform) {\n   *     if (this.platform.is('ios')) {\n   *       // This will only print when on iOS\n   *       console.log('I am an iOS device!');\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * | Platform Name   | Description                        |\n   * |-----------------|------------------------------------|\n   * | android         | on a device running Android.       |\n   * | capacitor       | on a device running Capacitor.     |\n   * | cordova         | on a device running Cordova.       |\n   * | ios             | on a device running iOS.           |\n   * | ipad            | on an iPad device.                 |\n   * | iphone          | on an iPhone device.               |\n   * | phablet         | on a phablet device.               |\n   * | tablet          | on a tablet device.                |\n   * | electron        | in Electron on a desktop device.   |\n   * | pwa             | as a PWA app.                      |\n   * | mobile          | on a mobile device.                |\n   * | mobileweb       | on a mobile device in a browser.   |\n   * | desktop         | on a desktop device.               |\n   * | hybrid          | is a cordova or capacitor app.     |\n   *\n   */\n\n\n  _createClass(Platform, [{\n    key: \"is\",\n    value: function is(platformName) {\n      return isPlatform(this.win, platformName);\n    }\n    /**\n     * @returns the array of platforms\n     * @description\n     * Depending on what device you are on, `platforms` can return multiple values.\n     * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n     * it would return `mobile`, `ios`, and `iphone`.\n     *\n     * ```\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyPage {\n     *   constructor(public platform: Platform) {\n     *     // This will print an array of the current platforms\n     *     console.log(this.platform.platforms());\n     *   }\n     * }\n     * ```\n     */\n\n  }, {\n    key: \"platforms\",\n    value: function platforms() {\n      return getPlatforms(this.win);\n    }\n    /**\n     * Returns a promise when the platform is ready and native functionality\n     * can be called. If the app is running from within a web browser, then\n     * the promise will resolve when the DOM is ready. When the app is running\n     * from an application engine such as Cordova, then the promise will\n     * resolve when Cordova triggers the `deviceready` event.\n     *\n     * The resolved value is the `readySource`, which states which platform\n     * ready was used. For example, when Cordova is ready, the resolved ready\n     * source is `cordova`. The default ready source value will be `dom`. The\n     * `readySource` is useful if different logic should run depending on the\n     * platform the app is running from. For example, only Cordova can execute\n     * the status bar plugin, so the web should not run status bar plugin logic.\n     *\n     * ```\n     * import { Component } from '@angular/core';\n     * import { Platform } from 'ionic-angular';\n     *\n     * @Component({...})\n     * export MyApp {\n     *   constructor(public platform: Platform) {\n     *     this.platform.ready().then((readySource) => {\n     *       console.log('Platform ready from', readySource);\n     *       // Platform now ready, execute any required native code\n     *     });\n     *   }\n     * }\n     * ```\n     */\n\n  }, {\n    key: \"ready\",\n    value: function ready() {\n      return this._readyPromise;\n    }\n    /**\n     * Returns if this app is using right-to-left language direction or not.\n     * We recommend the app's `index.html` file already has the correct `dir`\n     * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\n     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\n     */\n\n  }, {\n    key: \"isRTL\",\n    get: function get() {\n      return this.doc.dir === 'rtl';\n    }\n    /**\n     * Get the query string parameter\n     */\n\n  }, {\n    key: \"getQueryParam\",\n    value: function getQueryParam(key) {\n      return readQueryParam(this.win.location.href, key);\n    }\n    /**\n     * Returns `true` if the app is in landscape mode.\n     */\n\n  }, {\n    key: \"isLandscape\",\n    value: function isLandscape() {\n      return !this.isPortrait();\n    }\n    /**\n     * Returns `true` if the app is in portrait mode.\n     */\n\n  }, {\n    key: \"isPortrait\",\n    value: function isPortrait() {\n      return this.win.matchMedia && this.win.matchMedia('(orientation: portrait)').matches;\n    }\n  }, {\n    key: \"testUserAgent\",\n    value: function testUserAgent(expression) {\n      var nav = this.win.navigator;\n      return !!(nav && nav.userAgent && nav.userAgent.indexOf(expression) >= 0);\n    }\n    /**\n     * Get the current url.\n     */\n\n  }, {\n    key: \"url\",\n    value: function url() {\n      return this.win.location.href;\n    }\n    /**\n     * Gets the width of the platform's viewport using `window.innerWidth`.\n     */\n\n  }, {\n    key: \"width\",\n    value: function width() {\n      return this.win.innerWidth;\n    }\n    /**\n     * Gets the height of the platform's viewport using `window.innerHeight`.\n     */\n\n  }, {\n    key: \"height\",\n    value: function height() {\n      return this.win.innerHeight;\n    }\n  }]);\n\n  return Platform;\n}();\n\nPlatform.ɵfac = function Platform_Factory(t) {\n  return new (t || Platform)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n};\n\nPlatform.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: Platform,\n  factory: function factory(t) {\n    return Platform.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nPlatform.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function Platform_Factory() {\n    return new Platform(ɵɵinject(DOCUMENT), ɵɵinject(NgZone));\n  },\n  token: Platform,\n  providedIn: \"root\"\n});\nPlatform = __decorate([__param(0, Inject(DOCUMENT))], Platform);\n\nvar readQueryParam = function readQueryParam(url, key) {\n  key = key.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n  var regex = new RegExp('[\\\\?&]' + key + '=([^&#]*)');\n  var results = regex.exec(url);\n  return results ? decodeURIComponent(results[1].replace(/\\+/g, ' ')) : null;\n};\n\nvar ɵ0$1 = readQueryParam;\n\nvar proxyEvent = function proxyEvent(emitter, el, eventName) {\n  if (el) {\n    el.addEventListener(eventName, function (ev) {\n      // ?? cordova might emit \"null\" events\n      emitter.next(ev != null ? ev.detail : undefined);\n    });\n  }\n};\n\nvar ɵ1$1 = proxyEvent;\n\nvar NavController = /*#__PURE__*/function () {\n  function NavController(platform, location, serializer, router) {\n    var _this3 = this;\n\n    _classCallCheck(this, NavController);\n\n    this.location = location;\n    this.serializer = serializer;\n    this.router = router;\n    this.direction = DEFAULT_DIRECTION;\n    this.animated = DEFAULT_ANIMATED;\n    this.guessDirection = 'forward';\n    this.lastNavId = -1; // Subscribe to router events to detect direction\n\n    if (router) {\n      router.events.subscribe(function (ev) {\n        if (ev instanceof NavigationStart) {\n          var id = ev.restoredState ? ev.restoredState.navigationId : ev.id;\n          _this3.guessDirection = id < _this3.lastNavId ? 'back' : 'forward';\n          _this3.guessAnimation = !ev.restoredState ? _this3.guessDirection : undefined;\n          _this3.lastNavId = _this3.guessDirection === 'forward' ? ev.id : id;\n        }\n      });\n    } // Subscribe to backButton events\n\n\n    platform.backButton.subscribeWithPriority(0, function (processNextHandler) {\n      _this3.pop();\n\n      processNextHandler();\n    });\n  }\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n   *\n   * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n   * and that it will show a \"forward\" animation by default.\n   *\n   * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n   * ```\n   */\n\n\n  _createClass(NavController, [{\n    key: \"navigateForward\",\n    value: function navigateForward(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.setDirection('forward', options.animated, options.animationDirection, options.animation);\n      return this.navigate(url, options);\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('back');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n     * and that it will show a \"back\" animation by default.\n     *\n     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n     * ```\n     */\n\n  }, {\n    key: \"navigateBack\",\n    value: function navigateBack(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.setDirection('back', options.animated, options.animationDirection, options.animation);\n      return this.navigate(url, options);\n    }\n    /**\n     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n     * it's equivalent to calling:\n     *\n     * ```ts\n     * this.navController.setDirection('root');\n     * this.router.navigateByUrl(path);\n     * ```\n     *\n     * Going **root** means that all existing pages in the stack will be removed,\n     * and the navigated page will become the single page in the stack.\n     *\n     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n     *\n     * ```html\n     * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n     * ```\n     */\n\n  }, {\n    key: \"navigateRoot\",\n    value: function navigateRoot(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.setDirection('root', options.animated, options.animationDirection, options.animation);\n      return this.navigate(url, options);\n    }\n    /**\n     * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n     * by default.\n     */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        animated: true,\n        animationDirection: 'back'\n      };\n      this.setDirection('back', options.animated, options.animationDirection, options.animation);\n      return this.location.back();\n    }\n    /**\n     * This methods goes back in the context of Ionic's stack navigation.\n     *\n     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n     * This is the recommended way to go back when you are using `ion-router-outlet`.\n     */\n\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var outlet;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                outlet = this.topOutlet;\n\n              case 1:\n                if (!outlet) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 4;\n                return outlet.pop();\n\n              case 4:\n                if (!_context.sent) {\n                  _context.next = 8;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 11);\n\n              case 8:\n                outlet = outlet.parentOutlet;\n\n              case 9:\n                _context.next = 1;\n                break;\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * This methods specifies the direction of the next navigation performed by the Angular router.\n     *\n     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n     *\n     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n     */\n\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction, animated, animationDirection, animationBuilder) {\n      this.direction = direction;\n      this.animated = getAnimation(direction, animated, animationDirection);\n      this.animationBuilder = animationBuilder;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"setTopOutlet\",\n    value: function setTopOutlet(outlet) {\n      this.topOutlet = outlet;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"consumeTransition\",\n    value: function consumeTransition() {\n      var direction = 'root';\n      var animation;\n      var animationBuilder = this.animationBuilder;\n\n      if (this.direction === 'auto') {\n        direction = this.guessDirection;\n        animation = this.guessAnimation;\n      } else {\n        animation = this.animated;\n        direction = this.direction;\n      }\n\n      this.direction = DEFAULT_DIRECTION;\n      this.animated = DEFAULT_ANIMATED;\n      this.animationBuilder = undefined;\n      return {\n        direction: direction,\n        animation: animation,\n        animationBuilder: animationBuilder\n      };\n    }\n  }, {\n    key: \"navigate\",\n    value: function navigate(url, options) {\n      if (Array.isArray(url)) {\n        return this.router.navigate(url, options);\n      } else {\n        /**\n         * navigateByUrl ignores any properties that\n         * would change the url, so things like queryParams\n         * would be ignored unless we create a url tree\n         * More Info: https://github.com/angular/angular/issues/18798\n         */\n        var urlTree = this.serializer.parse(url.toString());\n\n        if (options.queryParams !== undefined) {\n          urlTree.queryParams = Object.assign({}, options.queryParams);\n        }\n\n        if (options.fragment !== undefined) {\n          urlTree.fragment = options.fragment;\n        }\n        /**\n         * `navigateByUrl` will still apply `NavigationExtras` properties\n         * that do not modify the url, such as `replaceUrl` which is why\n         * `options` is passed in here.\n         */\n\n\n        return this.router.navigateByUrl(urlTree, options);\n      }\n    }\n  }]);\n\n  return NavController;\n}();\n\nNavController.ɵfac = function NavController_Factory(t) {\n  return new (t || NavController)(ɵngcc0.ɵɵinject(Platform), ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc2.UrlSerializer), ɵngcc0.ɵɵinject(ɵngcc2.Router, 8));\n};\n\nNavController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: NavController,\n  factory: function factory(t) {\n    return NavController.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nNavController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function NavController_Factory() {\n    return new NavController(ɵɵinject(Platform), ɵɵinject(Location), ɵɵinject(UrlSerializer), ɵɵinject(Router, 8));\n  },\n  token: NavController,\n  providedIn: \"root\"\n});\nNavController = __decorate([__param(3, Optional())], NavController);\n\nvar getAnimation = function getAnimation(direction, animated, animationDirection) {\n  if (animated === false) {\n    return undefined;\n  }\n\n  if (animationDirection !== undefined) {\n    return animationDirection;\n  }\n\n  if (direction === 'forward' || direction === 'back') {\n    return direction;\n  } else if (direction === 'root' && animated === true) {\n    return 'forward';\n  }\n\n  return undefined;\n};\n\nvar ɵ0$2 = getAnimation;\nvar DEFAULT_DIRECTION = 'auto';\nvar DEFAULT_ANIMATED = undefined;\n/* eslint-disable */\n\nvar proxyInputs = function proxyInputs(Cmp, inputs) {\n  var Prototype = Cmp.prototype;\n  inputs.forEach(function (item) {\n    Object.defineProperty(Prototype, item, {\n      get: function get() {\n        return this.el[item];\n      },\n      set: function set(val) {\n        var _this4 = this;\n\n        this.z.runOutsideAngular(function () {\n          return _this4.el[item] = val;\n        });\n      }\n    });\n  });\n};\n\nvar proxyMethods = function proxyMethods(Cmp, methods) {\n  var Prototype = Cmp.prototype;\n  methods.forEach(function (methodName) {\n    Prototype[methodName] = function () {\n      var _this5 = this;\n\n      var args = arguments;\n      return this.z.runOutsideAngular(function () {\n        return _this5.el[methodName].apply(_this5.el, args);\n      });\n    };\n  });\n};\n\nvar proxyOutputs = function proxyOutputs(instance, el, events) {\n  events.forEach(function (eventName) {\n    return instance[eventName] = fromEvent(el, eventName);\n  });\n};\n\nfunction ProxyCmp(opts) {\n  var decorator = function decorator(cls) {\n    if (opts.inputs) {\n      proxyInputs(cls, opts.inputs);\n    }\n\n    if (opts.methods) {\n      proxyMethods(cls, opts.methods);\n    }\n\n    return cls;\n  };\n\n  return decorator;\n}\n\nvar IonApp = /*#__PURE__*/(function () {\n  var IonApp = function IonApp(c, r, z) {\n    _classCallCheck(this, IonApp);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonApp.ɵfac = function IonApp_Factory(t) {\n    return new (t || IonApp)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonApp.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonApp,\n    selectors: [[\"ion-app\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonApp_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IonApp;\n})();\nvar IonAvatar = /*#__PURE__*/(function () {\n  var IonAvatar = function IonAvatar(c, r, z) {\n    _classCallCheck(this, IonAvatar);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonAvatar.ɵfac = function IonAvatar_Factory(t) {\n    return new (t || IonAvatar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonAvatar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonAvatar,\n    selectors: [[\"ion-avatar\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonAvatar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IonAvatar;\n})();\nvar IonBackButton = /*#__PURE__*/(function () {\n  var IonBackButton = function IonBackButton(c, r, z) {\n    _classCallCheck(this, IonBackButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonBackButton.ɵfac = function IonBackButton_Factory(t) {\n    return new (t || IonBackButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonBackButton.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonBackButton,\n    selectors: [[\"ion-back-button\"]],\n    inputs: {\n      color: \"color\",\n      defaultHref: \"defaultHref\",\n      disabled: \"disabled\",\n      icon: \"icon\",\n      mode: \"mode\",\n      routerAnimation: \"routerAnimation\",\n      text: \"text\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonBackButton_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonBackButton = __decorate([ProxyCmp({\n    inputs: [\"color\", \"defaultHref\", \"disabled\", \"icon\", \"mode\", \"routerAnimation\", \"text\", \"type\"]\n  })], IonBackButton);\n  return IonBackButton;\n})();\nvar IonBackdrop = /*#__PURE__*/(function () {\n  var IonBackdrop = function IonBackdrop(c, r, z) {\n    _classCallCheck(this, IonBackdrop);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionBackdropTap\"]);\n  };\n\n  IonBackdrop.ɵfac = function IonBackdrop_Factory(t) {\n    return new (t || IonBackdrop)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonBackdrop.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonBackdrop,\n    selectors: [[\"ion-backdrop\"]],\n    inputs: {\n      stopPropagation: \"stopPropagation\",\n      tappable: \"tappable\",\n      visible: \"visible\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonBackdrop_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonBackdrop = __decorate([ProxyCmp({\n    inputs: [\"stopPropagation\", \"tappable\", \"visible\"]\n  })], IonBackdrop);\n  return IonBackdrop;\n})();\nvar IonBadge = /*#__PURE__*/(function () {\n  var IonBadge = function IonBadge(c, r, z) {\n    _classCallCheck(this, IonBadge);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonBadge.ɵfac = function IonBadge_Factory(t) {\n    return new (t || IonBadge)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonBadge.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonBadge,\n    selectors: [[\"ion-badge\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonBadge_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonBadge = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  })], IonBadge);\n  return IonBadge;\n})();\nvar IonButton = /*#__PURE__*/(function () {\n  var IonButton = function IonButton(c, r, z) {\n    _classCallCheck(this, IonButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionFocus\", \"ionBlur\"]);\n  };\n\n  IonButton.ɵfac = function IonButton_Factory(t) {\n    return new (t || IonButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonButton.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonButton,\n    selectors: [[\"ion-button\"]],\n    inputs: {\n      buttonType: \"buttonType\",\n      color: \"color\",\n      disabled: \"disabled\",\n      download: \"download\",\n      expand: \"expand\",\n      fill: \"fill\",\n      href: \"href\",\n      mode: \"mode\",\n      rel: \"rel\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\",\n      shape: \"shape\",\n      size: \"size\",\n      strong: \"strong\",\n      target: \"target\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonButton_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonButton = __decorate([ProxyCmp({\n    inputs: [\"buttonType\", \"color\", \"disabled\", \"download\", \"expand\", \"fill\", \"href\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"shape\", \"size\", \"strong\", \"target\", \"type\"]\n  })], IonButton);\n  return IonButton;\n})();\nvar IonButtons = /*#__PURE__*/(function () {\n  var IonButtons = function IonButtons(c, r, z) {\n    _classCallCheck(this, IonButtons);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonButtons.ɵfac = function IonButtons_Factory(t) {\n    return new (t || IonButtons)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonButtons.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonButtons,\n    selectors: [[\"ion-buttons\"]],\n    inputs: {\n      collapse: \"collapse\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonButtons_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonButtons = __decorate([ProxyCmp({\n    inputs: [\"collapse\"]\n  })], IonButtons);\n  return IonButtons;\n})();\nvar IonCard = /*#__PURE__*/(function () {\n  var IonCard = function IonCard(c, r, z) {\n    _classCallCheck(this, IonCard);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonCard.ɵfac = function IonCard_Factory(t) {\n    return new (t || IonCard)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonCard.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonCard,\n    selectors: [[\"ion-card\"]],\n    inputs: {\n      button: \"button\",\n      color: \"color\",\n      disabled: \"disabled\",\n      download: \"download\",\n      href: \"href\",\n      mode: \"mode\",\n      rel: \"rel\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\",\n      target: \"target\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCard_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCard = __decorate([ProxyCmp({\n    inputs: [\"button\", \"color\", \"disabled\", \"download\", \"href\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"target\", \"type\"]\n  })], IonCard);\n  return IonCard;\n})();\nvar IonCardContent = /*#__PURE__*/(function () {\n  var IonCardContent = function IonCardContent(c, r, z) {\n    _classCallCheck(this, IonCardContent);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonCardContent.ɵfac = function IonCardContent_Factory(t) {\n    return new (t || IonCardContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonCardContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonCardContent,\n    selectors: [[\"ion-card-content\"]],\n    inputs: {\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCardContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCardContent = __decorate([ProxyCmp({\n    inputs: [\"mode\"]\n  })], IonCardContent);\n  return IonCardContent;\n})();\nvar IonCardHeader = /*#__PURE__*/(function () {\n  var IonCardHeader = function IonCardHeader(c, r, z) {\n    _classCallCheck(this, IonCardHeader);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonCardHeader.ɵfac = function IonCardHeader_Factory(t) {\n    return new (t || IonCardHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonCardHeader.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonCardHeader,\n    selectors: [[\"ion-card-header\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\",\n      translucent: \"translucent\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCardHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCardHeader = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\", \"translucent\"]\n  })], IonCardHeader);\n  return IonCardHeader;\n})();\nvar IonCardSubtitle = /*#__PURE__*/(function () {\n  var IonCardSubtitle = function IonCardSubtitle(c, r, z) {\n    _classCallCheck(this, IonCardSubtitle);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonCardSubtitle.ɵfac = function IonCardSubtitle_Factory(t) {\n    return new (t || IonCardSubtitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonCardSubtitle.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonCardSubtitle,\n    selectors: [[\"ion-card-subtitle\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCardSubtitle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCardSubtitle = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  })], IonCardSubtitle);\n  return IonCardSubtitle;\n})();\nvar IonCardTitle = /*#__PURE__*/(function () {\n  var IonCardTitle = function IonCardTitle(c, r, z) {\n    _classCallCheck(this, IonCardTitle);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonCardTitle.ɵfac = function IonCardTitle_Factory(t) {\n    return new (t || IonCardTitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonCardTitle.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonCardTitle,\n    selectors: [[\"ion-card-title\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCardTitle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCardTitle = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  })], IonCardTitle);\n  return IonCardTitle;\n})();\nvar IonCheckbox = /*#__PURE__*/(function () {\n  var IonCheckbox = function IonCheckbox(c, r, z) {\n    _classCallCheck(this, IonCheckbox);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionChange\", \"ionFocus\", \"ionBlur\"]);\n  };\n\n  IonCheckbox.ɵfac = function IonCheckbox_Factory(t) {\n    return new (t || IonCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonCheckbox.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonCheckbox,\n    selectors: [[\"ion-checkbox\"]],\n    inputs: {\n      checked: \"checked\",\n      color: \"color\",\n      disabled: \"disabled\",\n      indeterminate: \"indeterminate\",\n      mode: \"mode\",\n      name: \"name\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCheckbox_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCheckbox = __decorate([ProxyCmp({\n    inputs: [\"checked\", \"color\", \"disabled\", \"indeterminate\", \"mode\", \"name\", \"value\"]\n  })], IonCheckbox);\n  return IonCheckbox;\n})();\nvar IonChip = /*#__PURE__*/(function () {\n  var IonChip = function IonChip(c, r, z) {\n    _classCallCheck(this, IonChip);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonChip.ɵfac = function IonChip_Factory(t) {\n    return new (t || IonChip)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonChip.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonChip,\n    selectors: [[\"ion-chip\"]],\n    inputs: {\n      color: \"color\",\n      disabled: \"disabled\",\n      mode: \"mode\",\n      outline: \"outline\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonChip_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonChip = __decorate([ProxyCmp({\n    inputs: [\"color\", \"disabled\", \"mode\", \"outline\"]\n  })], IonChip);\n  return IonChip;\n})();\nvar IonCol = /*#__PURE__*/(function () {\n  var IonCol = function IonCol(c, r, z) {\n    _classCallCheck(this, IonCol);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonCol.ɵfac = function IonCol_Factory(t) {\n    return new (t || IonCol)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonCol.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonCol,\n    selectors: [[\"ion-col\"]],\n    inputs: {\n      offset: \"offset\",\n      offsetLg: \"offsetLg\",\n      offsetMd: \"offsetMd\",\n      offsetSm: \"offsetSm\",\n      offsetXl: \"offsetXl\",\n      offsetXs: \"offsetXs\",\n      pull: \"pull\",\n      pullLg: \"pullLg\",\n      pullMd: \"pullMd\",\n      pullSm: \"pullSm\",\n      pullXl: \"pullXl\",\n      pullXs: \"pullXs\",\n      push: \"push\",\n      pushLg: \"pushLg\",\n      pushMd: \"pushMd\",\n      pushSm: \"pushSm\",\n      pushXl: \"pushXl\",\n      pushXs: \"pushXs\",\n      size: \"size\",\n      sizeLg: \"sizeLg\",\n      sizeMd: \"sizeMd\",\n      sizeSm: \"sizeSm\",\n      sizeXl: \"sizeXl\",\n      sizeXs: \"sizeXs\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonCol_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonCol = __decorate([ProxyCmp({\n    inputs: [\"offset\", \"offsetLg\", \"offsetMd\", \"offsetSm\", \"offsetXl\", \"offsetXs\", \"pull\", \"pullLg\", \"pullMd\", \"pullSm\", \"pullXl\", \"pullXs\", \"push\", \"pushLg\", \"pushMd\", \"pushSm\", \"pushXl\", \"pushXs\", \"size\", \"sizeLg\", \"sizeMd\", \"sizeSm\", \"sizeXl\", \"sizeXs\"]\n  })], IonCol);\n  return IonCol;\n})();\nvar IonContent = /*#__PURE__*/(function () {\n  var IonContent = function IonContent(c, r, z) {\n    _classCallCheck(this, IonContent);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionScrollStart\", \"ionScroll\", \"ionScrollEnd\"]);\n  };\n\n  IonContent.ɵfac = function IonContent_Factory(t) {\n    return new (t || IonContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonContent,\n    selectors: [[\"ion-content\"]],\n    inputs: {\n      color: \"color\",\n      forceOverscroll: \"forceOverscroll\",\n      fullscreen: \"fullscreen\",\n      scrollEvents: \"scrollEvents\",\n      scrollX: \"scrollX\",\n      scrollY: \"scrollY\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonContent = __decorate([ProxyCmp({\n    inputs: [\"color\", \"forceOverscroll\", \"fullscreen\", \"scrollEvents\", \"scrollX\", \"scrollY\"],\n    \"methods\": [\"getScrollElement\", \"scrollToTop\", \"scrollToBottom\", \"scrollByPoint\", \"scrollToPoint\"]\n  })], IonContent);\n  return IonContent;\n})();\nvar IonDatetime = /*#__PURE__*/(function () {\n  var IonDatetime = function IonDatetime(c, r, z) {\n    _classCallCheck(this, IonDatetime);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionCancel\", \"ionChange\", \"ionFocus\", \"ionBlur\"]);\n  };\n\n  IonDatetime.ɵfac = function IonDatetime_Factory(t) {\n    return new (t || IonDatetime)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonDatetime.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonDatetime,\n    selectors: [[\"ion-datetime\"]],\n    inputs: {\n      cancelText: \"cancelText\",\n      dayNames: \"dayNames\",\n      dayShortNames: \"dayShortNames\",\n      dayValues: \"dayValues\",\n      disabled: \"disabled\",\n      displayFormat: \"displayFormat\",\n      displayTimezone: \"displayTimezone\",\n      doneText: \"doneText\",\n      hourValues: \"hourValues\",\n      max: \"max\",\n      min: \"min\",\n      minuteValues: \"minuteValues\",\n      mode: \"mode\",\n      monthNames: \"monthNames\",\n      monthShortNames: \"monthShortNames\",\n      monthValues: \"monthValues\",\n      name: \"name\",\n      pickerFormat: \"pickerFormat\",\n      pickerOptions: \"pickerOptions\",\n      placeholder: \"placeholder\",\n      readonly: \"readonly\",\n      value: \"value\",\n      yearValues: \"yearValues\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonDatetime_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonDatetime = __decorate([ProxyCmp({\n    inputs: [\"cancelText\", \"dayNames\", \"dayShortNames\", \"dayValues\", \"disabled\", \"displayFormat\", \"displayTimezone\", \"doneText\", \"hourValues\", \"max\", \"min\", \"minuteValues\", \"mode\", \"monthNames\", \"monthShortNames\", \"monthValues\", \"name\", \"pickerFormat\", \"pickerOptions\", \"placeholder\", \"readonly\", \"value\", \"yearValues\"],\n    \"methods\": [\"open\"]\n  })], IonDatetime);\n  return IonDatetime;\n})();\nvar IonFab = /*#__PURE__*/(function () {\n  var IonFab = function IonFab(c, r, z) {\n    _classCallCheck(this, IonFab);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonFab.ɵfac = function IonFab_Factory(t) {\n    return new (t || IonFab)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonFab.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonFab,\n    selectors: [[\"ion-fab\"]],\n    inputs: {\n      activated: \"activated\",\n      edge: \"edge\",\n      horizontal: \"horizontal\",\n      vertical: \"vertical\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonFab_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonFab = __decorate([ProxyCmp({\n    inputs: [\"activated\", \"edge\", \"horizontal\", \"vertical\"],\n    \"methods\": [\"close\"]\n  })], IonFab);\n  return IonFab;\n})();\nvar IonFabButton = /*#__PURE__*/(function () {\n  var IonFabButton = function IonFabButton(c, r, z) {\n    _classCallCheck(this, IonFabButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionFocus\", \"ionBlur\"]);\n  };\n\n  IonFabButton.ɵfac = function IonFabButton_Factory(t) {\n    return new (t || IonFabButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonFabButton.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonFabButton,\n    selectors: [[\"ion-fab-button\"]],\n    inputs: {\n      activated: \"activated\",\n      closeIcon: \"closeIcon\",\n      color: \"color\",\n      disabled: \"disabled\",\n      download: \"download\",\n      href: \"href\",\n      mode: \"mode\",\n      rel: \"rel\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\",\n      show: \"show\",\n      size: \"size\",\n      target: \"target\",\n      translucent: \"translucent\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonFabButton_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonFabButton = __decorate([ProxyCmp({\n    inputs: [\"activated\", \"closeIcon\", \"color\", \"disabled\", \"download\", \"href\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"show\", \"size\", \"target\", \"translucent\", \"type\"]\n  })], IonFabButton);\n  return IonFabButton;\n})();\nvar IonFabList = /*#__PURE__*/(function () {\n  var IonFabList = function IonFabList(c, r, z) {\n    _classCallCheck(this, IonFabList);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonFabList.ɵfac = function IonFabList_Factory(t) {\n    return new (t || IonFabList)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonFabList.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonFabList,\n    selectors: [[\"ion-fab-list\"]],\n    inputs: {\n      activated: \"activated\",\n      side: \"side\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonFabList_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonFabList = __decorate([ProxyCmp({\n    inputs: [\"activated\", \"side\"]\n  })], IonFabList);\n  return IonFabList;\n})();\nvar IonFooter = /*#__PURE__*/(function () {\n  var IonFooter = function IonFooter(c, r, z) {\n    _classCallCheck(this, IonFooter);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonFooter.ɵfac = function IonFooter_Factory(t) {\n    return new (t || IonFooter)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonFooter.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonFooter,\n    selectors: [[\"ion-footer\"]],\n    inputs: {\n      mode: \"mode\",\n      translucent: \"translucent\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonFooter_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonFooter = __decorate([ProxyCmp({\n    inputs: [\"mode\", \"translucent\"]\n  })], IonFooter);\n  return IonFooter;\n})();\nvar IonGrid = /*#__PURE__*/(function () {\n  var IonGrid = function IonGrid(c, r, z) {\n    _classCallCheck(this, IonGrid);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonGrid.ɵfac = function IonGrid_Factory(t) {\n    return new (t || IonGrid)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonGrid.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonGrid,\n    selectors: [[\"ion-grid\"]],\n    inputs: {\n      fixed: \"fixed\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonGrid_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonGrid = __decorate([ProxyCmp({\n    inputs: [\"fixed\"]\n  })], IonGrid);\n  return IonGrid;\n})();\nvar IonHeader = /*#__PURE__*/(function () {\n  var IonHeader = function IonHeader(c, r, z) {\n    _classCallCheck(this, IonHeader);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonHeader.ɵfac = function IonHeader_Factory(t) {\n    return new (t || IonHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonHeader.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonHeader,\n    selectors: [[\"ion-header\"]],\n    inputs: {\n      collapse: \"collapse\",\n      mode: \"mode\",\n      translucent: \"translucent\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonHeader = __decorate([ProxyCmp({\n    inputs: [\"collapse\", \"mode\", \"translucent\"]\n  })], IonHeader);\n  return IonHeader;\n})();\nvar IonIcon = /*#__PURE__*/(function () {\n  var IonIcon = function IonIcon(c, r, z) {\n    _classCallCheck(this, IonIcon);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonIcon.ɵfac = function IonIcon_Factory(t) {\n    return new (t || IonIcon)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonIcon.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonIcon,\n    selectors: [[\"ion-icon\"]],\n    inputs: {\n      ariaHidden: \"ariaHidden\",\n      ariaLabel: \"ariaLabel\",\n      color: \"color\",\n      flipRtl: \"flipRtl\",\n      icon: \"icon\",\n      ios: \"ios\",\n      lazy: \"lazy\",\n      md: \"md\",\n      mode: \"mode\",\n      name: \"name\",\n      sanitize: \"sanitize\",\n      size: \"size\",\n      src: \"src\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonIcon_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonIcon = __decorate([ProxyCmp({\n    inputs: [\"ariaHidden\", \"ariaLabel\", \"color\", \"flipRtl\", \"icon\", \"ios\", \"lazy\", \"md\", \"mode\", \"name\", \"sanitize\", \"size\", \"src\"]\n  })], IonIcon);\n  return IonIcon;\n})();\nvar IonImg = /*#__PURE__*/(function () {\n  var IonImg = function IonImg(c, r, z) {\n    _classCallCheck(this, IonImg);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionImgWillLoad\", \"ionImgDidLoad\", \"ionError\"]);\n  };\n\n  IonImg.ɵfac = function IonImg_Factory(t) {\n    return new (t || IonImg)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonImg.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonImg,\n    selectors: [[\"ion-img\"]],\n    inputs: {\n      alt: \"alt\",\n      src: \"src\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonImg_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonImg = __decorate([ProxyCmp({\n    inputs: [\"alt\", \"src\"]\n  })], IonImg);\n  return IonImg;\n})();\nvar IonInfiniteScroll = /*#__PURE__*/(function () {\n  var IonInfiniteScroll = function IonInfiniteScroll(c, r, z) {\n    _classCallCheck(this, IonInfiniteScroll);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionInfinite\"]);\n  };\n\n  IonInfiniteScroll.ɵfac = function IonInfiniteScroll_Factory(t) {\n    return new (t || IonInfiniteScroll)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonInfiniteScroll.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonInfiniteScroll,\n    selectors: [[\"ion-infinite-scroll\"]],\n    inputs: {\n      disabled: \"disabled\",\n      position: \"position\",\n      threshold: \"threshold\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonInfiniteScroll_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonInfiniteScroll = __decorate([ProxyCmp({\n    inputs: [\"disabled\", \"position\", \"threshold\"],\n    \"methods\": [\"complete\"]\n  })], IonInfiniteScroll);\n  return IonInfiniteScroll;\n})();\nvar IonInfiniteScrollContent = /*#__PURE__*/(function () {\n  var IonInfiniteScrollContent = function IonInfiniteScrollContent(c, r, z) {\n    _classCallCheck(this, IonInfiniteScrollContent);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonInfiniteScrollContent.ɵfac = function IonInfiniteScrollContent_Factory(t) {\n    return new (t || IonInfiniteScrollContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonInfiniteScrollContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonInfiniteScrollContent,\n    selectors: [[\"ion-infinite-scroll-content\"]],\n    inputs: {\n      loadingSpinner: \"loadingSpinner\",\n      loadingText: \"loadingText\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonInfiniteScrollContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonInfiniteScrollContent = __decorate([ProxyCmp({\n    inputs: [\"loadingSpinner\", \"loadingText\"]\n  })], IonInfiniteScrollContent);\n  return IonInfiniteScrollContent;\n})();\nvar IonInput = /*#__PURE__*/(function () {\n  var IonInput = function IonInput(c, r, z) {\n    _classCallCheck(this, IonInput);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionInput\", \"ionChange\", \"ionBlur\", \"ionFocus\"]);\n  };\n\n  IonInput.ɵfac = function IonInput_Factory(t) {\n    return new (t || IonInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonInput.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonInput,\n    selectors: [[\"ion-input\"]],\n    inputs: {\n      accept: \"accept\",\n      autocapitalize: \"autocapitalize\",\n      autocomplete: \"autocomplete\",\n      autocorrect: \"autocorrect\",\n      autofocus: \"autofocus\",\n      clearInput: \"clearInput\",\n      clearOnEdit: \"clearOnEdit\",\n      color: \"color\",\n      debounce: \"debounce\",\n      disabled: \"disabled\",\n      enterkeyhint: \"enterkeyhint\",\n      inputmode: \"inputmode\",\n      max: \"max\",\n      maxlength: \"maxlength\",\n      min: \"min\",\n      minlength: \"minlength\",\n      mode: \"mode\",\n      multiple: \"multiple\",\n      name: \"name\",\n      pattern: \"pattern\",\n      placeholder: \"placeholder\",\n      readonly: \"readonly\",\n      required: \"required\",\n      size: \"size\",\n      spellcheck: \"spellcheck\",\n      step: \"step\",\n      type: \"type\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonInput_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonInput = __decorate([ProxyCmp({\n    inputs: [\"accept\", \"autocapitalize\", \"autocomplete\", \"autocorrect\", \"autofocus\", \"clearInput\", \"clearOnEdit\", \"color\", \"debounce\", \"disabled\", \"enterkeyhint\", \"inputmode\", \"max\", \"maxlength\", \"min\", \"minlength\", \"mode\", \"multiple\", \"name\", \"pattern\", \"placeholder\", \"readonly\", \"required\", \"size\", \"spellcheck\", \"step\", \"type\", \"value\"],\n    \"methods\": [\"setFocus\", \"getInputElement\"]\n  })], IonInput);\n  return IonInput;\n})();\nvar IonItem = /*#__PURE__*/(function () {\n  var IonItem = function IonItem(c, r, z) {\n    _classCallCheck(this, IonItem);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonItem.ɵfac = function IonItem_Factory(t) {\n    return new (t || IonItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonItem.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonItem,\n    selectors: [[\"ion-item\"]],\n    inputs: {\n      button: \"button\",\n      color: \"color\",\n      detail: \"detail\",\n      detailIcon: \"detailIcon\",\n      disabled: \"disabled\",\n      download: \"download\",\n      href: \"href\",\n      lines: \"lines\",\n      mode: \"mode\",\n      rel: \"rel\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\",\n      target: \"target\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItem_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItem = __decorate([ProxyCmp({\n    inputs: [\"button\", \"color\", \"detail\", \"detailIcon\", \"disabled\", \"download\", \"href\", \"lines\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"target\", \"type\"]\n  })], IonItem);\n  return IonItem;\n})();\nvar IonItemDivider = /*#__PURE__*/(function () {\n  var IonItemDivider = function IonItemDivider(c, r, z) {\n    _classCallCheck(this, IonItemDivider);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonItemDivider.ɵfac = function IonItemDivider_Factory(t) {\n    return new (t || IonItemDivider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonItemDivider.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonItemDivider,\n    selectors: [[\"ion-item-divider\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\",\n      sticky: \"sticky\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItemDivider_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItemDivider = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\", \"sticky\"]\n  })], IonItemDivider);\n  return IonItemDivider;\n})();\nvar IonItemGroup = /*#__PURE__*/(function () {\n  var IonItemGroup = function IonItemGroup(c, r, z) {\n    _classCallCheck(this, IonItemGroup);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonItemGroup.ɵfac = function IonItemGroup_Factory(t) {\n    return new (t || IonItemGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonItemGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonItemGroup,\n    selectors: [[\"ion-item-group\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItemGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IonItemGroup;\n})();\nvar IonItemOption = /*#__PURE__*/(function () {\n  var IonItemOption = function IonItemOption(c, r, z) {\n    _classCallCheck(this, IonItemOption);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonItemOption.ɵfac = function IonItemOption_Factory(t) {\n    return new (t || IonItemOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonItemOption.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonItemOption,\n    selectors: [[\"ion-item-option\"]],\n    inputs: {\n      color: \"color\",\n      disabled: \"disabled\",\n      download: \"download\",\n      expandable: \"expandable\",\n      href: \"href\",\n      mode: \"mode\",\n      rel: \"rel\",\n      target: \"target\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItemOption_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItemOption = __decorate([ProxyCmp({\n    inputs: [\"color\", \"disabled\", \"download\", \"expandable\", \"href\", \"mode\", \"rel\", \"target\", \"type\"]\n  })], IonItemOption);\n  return IonItemOption;\n})();\nvar IonItemOptions = /*#__PURE__*/(function () {\n  var IonItemOptions = function IonItemOptions(c, r, z) {\n    _classCallCheck(this, IonItemOptions);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionSwipe\"]);\n  };\n\n  IonItemOptions.ɵfac = function IonItemOptions_Factory(t) {\n    return new (t || IonItemOptions)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonItemOptions.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonItemOptions,\n    selectors: [[\"ion-item-options\"]],\n    inputs: {\n      side: \"side\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItemOptions_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItemOptions = __decorate([ProxyCmp({\n    inputs: [\"side\"]\n  })], IonItemOptions);\n  return IonItemOptions;\n})();\nvar IonItemSliding = /*#__PURE__*/(function () {\n  var IonItemSliding = function IonItemSliding(c, r, z) {\n    _classCallCheck(this, IonItemSliding);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionDrag\"]);\n  };\n\n  IonItemSliding.ɵfac = function IonItemSliding_Factory(t) {\n    return new (t || IonItemSliding)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonItemSliding.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonItemSliding,\n    selectors: [[\"ion-item-sliding\"]],\n    inputs: {\n      disabled: \"disabled\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonItemSliding_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonItemSliding = __decorate([ProxyCmp({\n    inputs: [\"disabled\"],\n    \"methods\": [\"getOpenAmount\", \"getSlidingRatio\", \"open\", \"close\", \"closeOpened\"]\n  })], IonItemSliding);\n  return IonItemSliding;\n})();\nvar IonLabel = /*#__PURE__*/(function () {\n  var IonLabel = function IonLabel(c, r, z) {\n    _classCallCheck(this, IonLabel);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonLabel.ɵfac = function IonLabel_Factory(t) {\n    return new (t || IonLabel)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonLabel.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonLabel,\n    selectors: [[\"ion-label\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\",\n      position: \"position\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonLabel_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonLabel = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\", \"position\"]\n  })], IonLabel);\n  return IonLabel;\n})();\nvar IonList = /*#__PURE__*/(function () {\n  var IonList = function IonList(c, r, z) {\n    _classCallCheck(this, IonList);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonList.ɵfac = function IonList_Factory(t) {\n    return new (t || IonList)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonList.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonList,\n    selectors: [[\"ion-list\"]],\n    inputs: {\n      inset: \"inset\",\n      lines: \"lines\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonList_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonList = __decorate([ProxyCmp({\n    inputs: [\"inset\", \"lines\", \"mode\"],\n    \"methods\": [\"closeSlidingItems\"]\n  })], IonList);\n  return IonList;\n})();\nvar IonListHeader = /*#__PURE__*/(function () {\n  var IonListHeader = function IonListHeader(c, r, z) {\n    _classCallCheck(this, IonListHeader);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonListHeader.ɵfac = function IonListHeader_Factory(t) {\n    return new (t || IonListHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonListHeader.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonListHeader,\n    selectors: [[\"ion-list-header\"]],\n    inputs: {\n      color: \"color\",\n      lines: \"lines\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonListHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonListHeader = __decorate([ProxyCmp({\n    inputs: [\"color\", \"lines\", \"mode\"]\n  })], IonListHeader);\n  return IonListHeader;\n})();\nvar IonMenu = /*#__PURE__*/(function () {\n  var IonMenu = function IonMenu(c, r, z) {\n    _classCallCheck(this, IonMenu);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionWillOpen\", \"ionWillClose\", \"ionDidOpen\", \"ionDidClose\"]);\n  };\n\n  IonMenu.ɵfac = function IonMenu_Factory(t) {\n    return new (t || IonMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonMenu.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonMenu,\n    selectors: [[\"ion-menu\"]],\n    inputs: {\n      contentId: \"contentId\",\n      disabled: \"disabled\",\n      maxEdgeStart: \"maxEdgeStart\",\n      menuId: \"menuId\",\n      side: \"side\",\n      swipeGesture: \"swipeGesture\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonMenu_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonMenu = __decorate([ProxyCmp({\n    inputs: [\"contentId\", \"disabled\", \"maxEdgeStart\", \"menuId\", \"side\", \"swipeGesture\", \"type\"],\n    \"methods\": [\"isOpen\", \"isActive\", \"open\", \"close\", \"toggle\", \"setOpen\"]\n  })], IonMenu);\n  return IonMenu;\n})();\nvar IonMenuButton = /*#__PURE__*/(function () {\n  var IonMenuButton = function IonMenuButton(c, r, z) {\n    _classCallCheck(this, IonMenuButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonMenuButton.ɵfac = function IonMenuButton_Factory(t) {\n    return new (t || IonMenuButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonMenuButton.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonMenuButton,\n    selectors: [[\"ion-menu-button\"]],\n    inputs: {\n      autoHide: \"autoHide\",\n      color: \"color\",\n      disabled: \"disabled\",\n      menu: \"menu\",\n      mode: \"mode\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonMenuButton_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonMenuButton = __decorate([ProxyCmp({\n    inputs: [\"autoHide\", \"color\", \"disabled\", \"menu\", \"mode\", \"type\"]\n  })], IonMenuButton);\n  return IonMenuButton;\n})();\nvar IonMenuToggle = /*#__PURE__*/(function () {\n  var IonMenuToggle = function IonMenuToggle(c, r, z) {\n    _classCallCheck(this, IonMenuToggle);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonMenuToggle.ɵfac = function IonMenuToggle_Factory(t) {\n    return new (t || IonMenuToggle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonMenuToggle.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonMenuToggle,\n    selectors: [[\"ion-menu-toggle\"]],\n    inputs: {\n      autoHide: \"autoHide\",\n      menu: \"menu\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonMenuToggle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonMenuToggle = __decorate([ProxyCmp({\n    inputs: [\"autoHide\", \"menu\"]\n  })], IonMenuToggle);\n  return IonMenuToggle;\n})();\nvar IonNav = /*#__PURE__*/(function () {\n  var IonNav = function IonNav(c, r, z) {\n    _classCallCheck(this, IonNav);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionNavWillChange\", \"ionNavDidChange\"]);\n  };\n\n  IonNav.ɵfac = function IonNav_Factory(t) {\n    return new (t || IonNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonNav.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonNav,\n    selectors: [[\"ion-nav\"]],\n    inputs: {\n      animated: \"animated\",\n      animation: \"animation\",\n      root: \"root\",\n      rootParams: \"rootParams\",\n      swipeGesture: \"swipeGesture\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonNav_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonNav = __decorate([ProxyCmp({\n    inputs: [\"animated\", \"animation\", \"root\", \"rootParams\", \"swipeGesture\"],\n    \"methods\": [\"push\", \"insert\", \"insertPages\", \"pop\", \"popTo\", \"popToRoot\", \"removeIndex\", \"setRoot\", \"setPages\", \"getActive\", \"getByIndex\", \"canGoBack\", \"getPrevious\"]\n  })], IonNav);\n  return IonNav;\n})();\nvar IonNavLink = /*#__PURE__*/(function () {\n  var IonNavLink = function IonNavLink(c, r, z) {\n    _classCallCheck(this, IonNavLink);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonNavLink.ɵfac = function IonNavLink_Factory(t) {\n    return new (t || IonNavLink)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonNavLink.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonNavLink,\n    selectors: [[\"ion-nav-link\"]],\n    inputs: {\n      component: \"component\",\n      componentProps: \"componentProps\",\n      routerAnimation: \"routerAnimation\",\n      routerDirection: \"routerDirection\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonNavLink_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonNavLink = __decorate([ProxyCmp({\n    inputs: [\"component\", \"componentProps\", \"routerAnimation\", \"routerDirection\"]\n  })], IonNavLink);\n  return IonNavLink;\n})();\nvar IonNote = /*#__PURE__*/(function () {\n  var IonNote = function IonNote(c, r, z) {\n    _classCallCheck(this, IonNote);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonNote.ɵfac = function IonNote_Factory(t) {\n    return new (t || IonNote)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonNote.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonNote,\n    selectors: [[\"ion-note\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonNote_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonNote = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  })], IonNote);\n  return IonNote;\n})();\nvar IonProgressBar = /*#__PURE__*/(function () {\n  var IonProgressBar = function IonProgressBar(c, r, z) {\n    _classCallCheck(this, IonProgressBar);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonProgressBar.ɵfac = function IonProgressBar_Factory(t) {\n    return new (t || IonProgressBar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonProgressBar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonProgressBar,\n    selectors: [[\"ion-progress-bar\"]],\n    inputs: {\n      buffer: \"buffer\",\n      color: \"color\",\n      mode: \"mode\",\n      reversed: \"reversed\",\n      type: \"type\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonProgressBar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonProgressBar = __decorate([ProxyCmp({\n    inputs: [\"buffer\", \"color\", \"mode\", \"reversed\", \"type\", \"value\"]\n  })], IonProgressBar);\n  return IonProgressBar;\n})();\nvar IonRadio = /*#__PURE__*/(function () {\n  var IonRadio = function IonRadio(c, r, z) {\n    _classCallCheck(this, IonRadio);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionFocus\", \"ionBlur\"]);\n  };\n\n  IonRadio.ɵfac = function IonRadio_Factory(t) {\n    return new (t || IonRadio)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonRadio.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonRadio,\n    selectors: [[\"ion-radio\"]],\n    inputs: {\n      color: \"color\",\n      disabled: \"disabled\",\n      mode: \"mode\",\n      name: \"name\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRadio_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRadio = __decorate([ProxyCmp({\n    inputs: [\"color\", \"disabled\", \"mode\", \"name\", \"value\"]\n  })], IonRadio);\n  return IonRadio;\n})();\nvar IonRadioGroup = /*#__PURE__*/(function () {\n  var IonRadioGroup = function IonRadioGroup(c, r, z) {\n    _classCallCheck(this, IonRadioGroup);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionChange\"]);\n  };\n\n  IonRadioGroup.ɵfac = function IonRadioGroup_Factory(t) {\n    return new (t || IonRadioGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonRadioGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonRadioGroup,\n    selectors: [[\"ion-radio-group\"]],\n    inputs: {\n      allowEmptySelection: \"allowEmptySelection\",\n      name: \"name\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRadioGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRadioGroup = __decorate([ProxyCmp({\n    inputs: [\"allowEmptySelection\", \"name\", \"value\"]\n  })], IonRadioGroup);\n  return IonRadioGroup;\n})();\nvar IonRange = /*#__PURE__*/(function () {\n  var IonRange = function IonRange(c, r, z) {\n    _classCallCheck(this, IonRange);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionChange\", \"ionFocus\", \"ionBlur\"]);\n  };\n\n  IonRange.ɵfac = function IonRange_Factory(t) {\n    return new (t || IonRange)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonRange.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonRange,\n    selectors: [[\"ion-range\"]],\n    inputs: {\n      color: \"color\",\n      debounce: \"debounce\",\n      disabled: \"disabled\",\n      dualKnobs: \"dualKnobs\",\n      max: \"max\",\n      min: \"min\",\n      mode: \"mode\",\n      name: \"name\",\n      pin: \"pin\",\n      snaps: \"snaps\",\n      step: \"step\",\n      ticks: \"ticks\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRange_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRange = __decorate([ProxyCmp({\n    inputs: [\"color\", \"debounce\", \"disabled\", \"dualKnobs\", \"max\", \"min\", \"mode\", \"name\", \"pin\", \"snaps\", \"step\", \"ticks\", \"value\"]\n  })], IonRange);\n  return IonRange;\n})();\nvar IonRefresher = /*#__PURE__*/(function () {\n  var IonRefresher = function IonRefresher(c, r, z) {\n    _classCallCheck(this, IonRefresher);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionRefresh\", \"ionPull\", \"ionStart\"]);\n  };\n\n  IonRefresher.ɵfac = function IonRefresher_Factory(t) {\n    return new (t || IonRefresher)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonRefresher.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonRefresher,\n    selectors: [[\"ion-refresher\"]],\n    inputs: {\n      closeDuration: \"closeDuration\",\n      disabled: \"disabled\",\n      pullFactor: \"pullFactor\",\n      pullMax: \"pullMax\",\n      pullMin: \"pullMin\",\n      snapbackDuration: \"snapbackDuration\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRefresher_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRefresher = __decorate([ProxyCmp({\n    inputs: [\"closeDuration\", \"disabled\", \"pullFactor\", \"pullMax\", \"pullMin\", \"snapbackDuration\"],\n    \"methods\": [\"complete\", \"cancel\", \"getProgress\"]\n  })], IonRefresher);\n  return IonRefresher;\n})();\nvar IonRefresherContent = /*#__PURE__*/(function () {\n  var IonRefresherContent = function IonRefresherContent(c, r, z) {\n    _classCallCheck(this, IonRefresherContent);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonRefresherContent.ɵfac = function IonRefresherContent_Factory(t) {\n    return new (t || IonRefresherContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonRefresherContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonRefresherContent,\n    selectors: [[\"ion-refresher-content\"]],\n    inputs: {\n      pullingIcon: \"pullingIcon\",\n      pullingText: \"pullingText\",\n      refreshingSpinner: \"refreshingSpinner\",\n      refreshingText: \"refreshingText\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRefresherContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRefresherContent = __decorate([ProxyCmp({\n    inputs: [\"pullingIcon\", \"pullingText\", \"refreshingSpinner\", \"refreshingText\"]\n  })], IonRefresherContent);\n  return IonRefresherContent;\n})();\nvar IonReorder = /*#__PURE__*/(function () {\n  var IonReorder = function IonReorder(c, r, z) {\n    _classCallCheck(this, IonReorder);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonReorder.ɵfac = function IonReorder_Factory(t) {\n    return new (t || IonReorder)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonReorder.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonReorder,\n    selectors: [[\"ion-reorder\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonReorder_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IonReorder;\n})();\nvar IonReorderGroup = /*#__PURE__*/(function () {\n  var IonReorderGroup = function IonReorderGroup(c, r, z) {\n    _classCallCheck(this, IonReorderGroup);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionItemReorder\"]);\n  };\n\n  IonReorderGroup.ɵfac = function IonReorderGroup_Factory(t) {\n    return new (t || IonReorderGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonReorderGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonReorderGroup,\n    selectors: [[\"ion-reorder-group\"]],\n    inputs: {\n      disabled: \"disabled\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonReorderGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonReorderGroup = __decorate([ProxyCmp({\n    inputs: [\"disabled\"],\n    \"methods\": [\"complete\"]\n  })], IonReorderGroup);\n  return IonReorderGroup;\n})();\nvar IonRippleEffect = /*#__PURE__*/(function () {\n  var IonRippleEffect = function IonRippleEffect(c, r, z) {\n    _classCallCheck(this, IonRippleEffect);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonRippleEffect.ɵfac = function IonRippleEffect_Factory(t) {\n    return new (t || IonRippleEffect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonRippleEffect.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonRippleEffect,\n    selectors: [[\"ion-ripple-effect\"]],\n    inputs: {\n      type: \"type\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRippleEffect_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonRippleEffect = __decorate([ProxyCmp({\n    inputs: [\"type\"],\n    \"methods\": [\"addRipple\"]\n  })], IonRippleEffect);\n  return IonRippleEffect;\n})();\nvar IonRow = /*#__PURE__*/(function () {\n  var IonRow = function IonRow(c, r, z) {\n    _classCallCheck(this, IonRow);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonRow.ɵfac = function IonRow_Factory(t) {\n    return new (t || IonRow)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonRow.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonRow,\n    selectors: [[\"ion-row\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonRow_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IonRow;\n})();\nvar IonSearchbar = /*#__PURE__*/(function () {\n  var IonSearchbar = function IonSearchbar(c, r, z) {\n    _classCallCheck(this, IonSearchbar);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionInput\", \"ionChange\", \"ionCancel\", \"ionClear\", \"ionBlur\", \"ionFocus\"]);\n  };\n\n  IonSearchbar.ɵfac = function IonSearchbar_Factory(t) {\n    return new (t || IonSearchbar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonSearchbar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonSearchbar,\n    selectors: [[\"ion-searchbar\"]],\n    inputs: {\n      animated: \"animated\",\n      autocomplete: \"autocomplete\",\n      autocorrect: \"autocorrect\",\n      cancelButtonIcon: \"cancelButtonIcon\",\n      cancelButtonText: \"cancelButtonText\",\n      clearIcon: \"clearIcon\",\n      color: \"color\",\n      debounce: \"debounce\",\n      disabled: \"disabled\",\n      enterkeyhint: \"enterkeyhint\",\n      inputmode: \"inputmode\",\n      mode: \"mode\",\n      placeholder: \"placeholder\",\n      searchIcon: \"searchIcon\",\n      showCancelButton: \"showCancelButton\",\n      showClearButton: \"showClearButton\",\n      spellcheck: \"spellcheck\",\n      type: \"type\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSearchbar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSearchbar = __decorate([ProxyCmp({\n    inputs: [\"animated\", \"autocomplete\", \"autocorrect\", \"cancelButtonIcon\", \"cancelButtonText\", \"clearIcon\", \"color\", \"debounce\", \"disabled\", \"enterkeyhint\", \"inputmode\", \"mode\", \"placeholder\", \"searchIcon\", \"showCancelButton\", \"showClearButton\", \"spellcheck\", \"type\", \"value\"],\n    \"methods\": [\"setFocus\", \"getInputElement\"]\n  })], IonSearchbar);\n  return IonSearchbar;\n})();\nvar IonSegment = /*#__PURE__*/(function () {\n  var IonSegment = function IonSegment(c, r, z) {\n    _classCallCheck(this, IonSegment);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionChange\"]);\n  };\n\n  IonSegment.ɵfac = function IonSegment_Factory(t) {\n    return new (t || IonSegment)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonSegment.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonSegment,\n    selectors: [[\"ion-segment\"]],\n    inputs: {\n      color: \"color\",\n      disabled: \"disabled\",\n      mode: \"mode\",\n      scrollable: \"scrollable\",\n      swipeGesture: \"swipeGesture\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSegment_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSegment = __decorate([ProxyCmp({\n    inputs: [\"color\", \"disabled\", \"mode\", \"scrollable\", \"swipeGesture\", \"value\"]\n  })], IonSegment);\n  return IonSegment;\n})();\nvar IonSegmentButton = /*#__PURE__*/(function () {\n  var IonSegmentButton = function IonSegmentButton(c, r, z) {\n    _classCallCheck(this, IonSegmentButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonSegmentButton.ɵfac = function IonSegmentButton_Factory(t) {\n    return new (t || IonSegmentButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonSegmentButton.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonSegmentButton,\n    selectors: [[\"ion-segment-button\"]],\n    inputs: {\n      disabled: \"disabled\",\n      layout: \"layout\",\n      mode: \"mode\",\n      type: \"type\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSegmentButton_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSegmentButton = __decorate([ProxyCmp({\n    inputs: [\"disabled\", \"layout\", \"mode\", \"type\", \"value\"]\n  })], IonSegmentButton);\n  return IonSegmentButton;\n})();\nvar IonSelect = /*#__PURE__*/(function () {\n  var IonSelect = function IonSelect(c, r, z) {\n    _classCallCheck(this, IonSelect);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionChange\", \"ionCancel\", \"ionFocus\", \"ionBlur\"]);\n  };\n\n  IonSelect.ɵfac = function IonSelect_Factory(t) {\n    return new (t || IonSelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonSelect.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonSelect,\n    selectors: [[\"ion-select\"]],\n    inputs: {\n      cancelText: \"cancelText\",\n      compareWith: \"compareWith\",\n      disabled: \"disabled\",\n      interface: \"interface\",\n      interfaceOptions: \"interfaceOptions\",\n      mode: \"mode\",\n      multiple: \"multiple\",\n      name: \"name\",\n      okText: \"okText\",\n      placeholder: \"placeholder\",\n      selectedText: \"selectedText\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSelect_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSelect = __decorate([ProxyCmp({\n    inputs: [\"cancelText\", \"compareWith\", \"disabled\", \"interface\", \"interfaceOptions\", \"mode\", \"multiple\", \"name\", \"okText\", \"placeholder\", \"selectedText\", \"value\"],\n    \"methods\": [\"open\"]\n  })], IonSelect);\n  return IonSelect;\n})();\nvar IonSelectOption = /*#__PURE__*/(function () {\n  var IonSelectOption = function IonSelectOption(c, r, z) {\n    _classCallCheck(this, IonSelectOption);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonSelectOption.ɵfac = function IonSelectOption_Factory(t) {\n    return new (t || IonSelectOption)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonSelectOption.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonSelectOption,\n    selectors: [[\"ion-select-option\"]],\n    inputs: {\n      disabled: \"disabled\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSelectOption_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSelectOption = __decorate([ProxyCmp({\n    inputs: [\"disabled\", \"value\"]\n  })], IonSelectOption);\n  return IonSelectOption;\n})();\nvar IonSkeletonText = /*#__PURE__*/(function () {\n  var IonSkeletonText = function IonSkeletonText(c, r, z) {\n    _classCallCheck(this, IonSkeletonText);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonSkeletonText.ɵfac = function IonSkeletonText_Factory(t) {\n    return new (t || IonSkeletonText)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonSkeletonText.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonSkeletonText,\n    selectors: [[\"ion-skeleton-text\"]],\n    inputs: {\n      animated: \"animated\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSkeletonText_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSkeletonText = __decorate([ProxyCmp({\n    inputs: [\"animated\"]\n  })], IonSkeletonText);\n  return IonSkeletonText;\n})();\nvar IonSlide = /*#__PURE__*/(function () {\n  var IonSlide = function IonSlide(c, r, z) {\n    _classCallCheck(this, IonSlide);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonSlide.ɵfac = function IonSlide_Factory(t) {\n    return new (t || IonSlide)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonSlide.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonSlide,\n    selectors: [[\"ion-slide\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSlide_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IonSlide;\n})();\nvar IonSlides = /*#__PURE__*/(function () {\n  var IonSlides = function IonSlides(c, r, z) {\n    _classCallCheck(this, IonSlides);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionSlidesDidLoad\", \"ionSlideTap\", \"ionSlideDoubleTap\", \"ionSlideWillChange\", \"ionSlideDidChange\", \"ionSlideNextStart\", \"ionSlidePrevStart\", \"ionSlideNextEnd\", \"ionSlidePrevEnd\", \"ionSlideTransitionStart\", \"ionSlideTransitionEnd\", \"ionSlideDrag\", \"ionSlideReachStart\", \"ionSlideReachEnd\", \"ionSlideTouchStart\", \"ionSlideTouchEnd\"]);\n  };\n\n  IonSlides.ɵfac = function IonSlides_Factory(t) {\n    return new (t || IonSlides)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonSlides.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonSlides,\n    selectors: [[\"ion-slides\"]],\n    inputs: {\n      mode: \"mode\",\n      options: \"options\",\n      pager: \"pager\",\n      scrollbar: \"scrollbar\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSlides_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSlides = __decorate([ProxyCmp({\n    inputs: [\"mode\", \"options\", \"pager\", \"scrollbar\"],\n    \"methods\": [\"update\", \"updateAutoHeight\", \"slideTo\", \"slideNext\", \"slidePrev\", \"getActiveIndex\", \"getPreviousIndex\", \"length\", \"isEnd\", \"isBeginning\", \"startAutoplay\", \"stopAutoplay\", \"lockSwipeToNext\", \"lockSwipeToPrev\", \"lockSwipes\", \"getSwiper\"]\n  })], IonSlides);\n  return IonSlides;\n})();\nvar IonSpinner = /*#__PURE__*/(function () {\n  var IonSpinner = function IonSpinner(c, r, z) {\n    _classCallCheck(this, IonSpinner);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonSpinner.ɵfac = function IonSpinner_Factory(t) {\n    return new (t || IonSpinner)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonSpinner.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonSpinner,\n    selectors: [[\"ion-spinner\"]],\n    inputs: {\n      color: \"color\",\n      duration: \"duration\",\n      name: \"name\",\n      paused: \"paused\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSpinner_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSpinner = __decorate([ProxyCmp({\n    inputs: [\"color\", \"duration\", \"name\", \"paused\"]\n  })], IonSpinner);\n  return IonSpinner;\n})();\nvar IonSplitPane = /*#__PURE__*/(function () {\n  var IonSplitPane = function IonSplitPane(c, r, z) {\n    _classCallCheck(this, IonSplitPane);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionSplitPaneVisible\"]);\n  };\n\n  IonSplitPane.ɵfac = function IonSplitPane_Factory(t) {\n    return new (t || IonSplitPane)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonSplitPane.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonSplitPane,\n    selectors: [[\"ion-split-pane\"]],\n    inputs: {\n      contentId: \"contentId\",\n      disabled: \"disabled\",\n      when: \"when\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonSplitPane_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonSplitPane = __decorate([ProxyCmp({\n    inputs: [\"contentId\", \"disabled\", \"when\"]\n  })], IonSplitPane);\n  return IonSplitPane;\n})();\nvar IonTabBar = /*#__PURE__*/(function () {\n  var IonTabBar = function IonTabBar(c, r, z) {\n    _classCallCheck(this, IonTabBar);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonTabBar.ɵfac = function IonTabBar_Factory(t) {\n    return new (t || IonTabBar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonTabBar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonTabBar,\n    selectors: [[\"ion-tab-bar\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\",\n      selectedTab: \"selectedTab\",\n      translucent: \"translucent\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonTabBar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonTabBar = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\", \"selectedTab\", \"translucent\"]\n  })], IonTabBar);\n  return IonTabBar;\n})();\nvar IonTabButton = /*#__PURE__*/(function () {\n  var IonTabButton = function IonTabButton(c, r, z) {\n    _classCallCheck(this, IonTabButton);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonTabButton.ɵfac = function IonTabButton_Factory(t) {\n    return new (t || IonTabButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonTabButton.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonTabButton,\n    selectors: [[\"ion-tab-button\"]],\n    inputs: {\n      disabled: \"disabled\",\n      download: \"download\",\n      href: \"href\",\n      layout: \"layout\",\n      mode: \"mode\",\n      rel: \"rel\",\n      selected: \"selected\",\n      tab: \"tab\",\n      target: \"target\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonTabButton_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonTabButton = __decorate([ProxyCmp({\n    inputs: [\"disabled\", \"download\", \"href\", \"layout\", \"mode\", \"rel\", \"selected\", \"tab\", \"target\"]\n  })], IonTabButton);\n  return IonTabButton;\n})();\nvar IonText = /*#__PURE__*/(function () {\n  var IonText = function IonText(c, r, z) {\n    _classCallCheck(this, IonText);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonText.ɵfac = function IonText_Factory(t) {\n    return new (t || IonText)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonText.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonText,\n    selectors: [[\"ion-text\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonText_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonText = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  })], IonText);\n  return IonText;\n})();\nvar IonTextarea = /*#__PURE__*/(function () {\n  var IonTextarea = function IonTextarea(c, r, z) {\n    _classCallCheck(this, IonTextarea);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionChange\", \"ionInput\", \"ionBlur\", \"ionFocus\"]);\n  };\n\n  IonTextarea.ɵfac = function IonTextarea_Factory(t) {\n    return new (t || IonTextarea)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonTextarea.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonTextarea,\n    selectors: [[\"ion-textarea\"]],\n    inputs: {\n      autoGrow: \"autoGrow\",\n      autocapitalize: \"autocapitalize\",\n      autofocus: \"autofocus\",\n      clearOnEdit: \"clearOnEdit\",\n      color: \"color\",\n      cols: \"cols\",\n      debounce: \"debounce\",\n      disabled: \"disabled\",\n      enterkeyhint: \"enterkeyhint\",\n      inputmode: \"inputmode\",\n      maxlength: \"maxlength\",\n      minlength: \"minlength\",\n      mode: \"mode\",\n      name: \"name\",\n      placeholder: \"placeholder\",\n      readonly: \"readonly\",\n      required: \"required\",\n      rows: \"rows\",\n      spellcheck: \"spellcheck\",\n      value: \"value\",\n      wrap: \"wrap\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonTextarea_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonTextarea = __decorate([ProxyCmp({\n    inputs: [\"autoGrow\", \"autocapitalize\", \"autofocus\", \"clearOnEdit\", \"color\", \"cols\", \"debounce\", \"disabled\", \"enterkeyhint\", \"inputmode\", \"maxlength\", \"minlength\", \"mode\", \"name\", \"placeholder\", \"readonly\", \"required\", \"rows\", \"spellcheck\", \"value\", \"wrap\"],\n    \"methods\": [\"setFocus\", \"getInputElement\"]\n  })], IonTextarea);\n  return IonTextarea;\n})();\nvar IonThumbnail = /*#__PURE__*/(function () {\n  var IonThumbnail = function IonThumbnail(c, r, z) {\n    _classCallCheck(this, IonThumbnail);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonThumbnail.ɵfac = function IonThumbnail_Factory(t) {\n    return new (t || IonThumbnail)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonThumbnail.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonThumbnail,\n    selectors: [[\"ion-thumbnail\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonThumbnail_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return IonThumbnail;\n})();\nvar IonTitle = /*#__PURE__*/(function () {\n  var IonTitle = function IonTitle(c, r, z) {\n    _classCallCheck(this, IonTitle);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonTitle.ɵfac = function IonTitle_Factory(t) {\n    return new (t || IonTitle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonTitle.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonTitle,\n    selectors: [[\"ion-title\"]],\n    inputs: {\n      color: \"color\",\n      size: \"size\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonTitle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonTitle = __decorate([ProxyCmp({\n    inputs: [\"color\", \"size\"]\n  })], IonTitle);\n  return IonTitle;\n})();\nvar IonToggle = /*#__PURE__*/(function () {\n  var IonToggle = function IonToggle(c, r, z) {\n    _classCallCheck(this, IonToggle);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n    proxyOutputs(this, this.el, [\"ionChange\", \"ionFocus\", \"ionBlur\"]);\n  };\n\n  IonToggle.ɵfac = function IonToggle_Factory(t) {\n    return new (t || IonToggle)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonToggle.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonToggle,\n    selectors: [[\"ion-toggle\"]],\n    inputs: {\n      checked: \"checked\",\n      color: \"color\",\n      disabled: \"disabled\",\n      mode: \"mode\",\n      name: \"name\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonToggle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonToggle = __decorate([ProxyCmp({\n    inputs: [\"checked\", \"color\", \"disabled\", \"mode\", \"name\", \"value\"]\n  })], IonToggle);\n  return IonToggle;\n})();\nvar IonToolbar = /*#__PURE__*/(function () {\n  var IonToolbar = function IonToolbar(c, r, z) {\n    _classCallCheck(this, IonToolbar);\n\n    this.z = z;\n    c.detach();\n    this.el = r.nativeElement;\n  };\n\n  IonToolbar.ɵfac = function IonToolbar_Factory(t) {\n    return new (t || IonToolbar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  IonToolbar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonToolbar,\n    selectors: [[\"ion-toolbar\"]],\n    inputs: {\n      color: \"color\",\n      mode: \"mode\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonToolbar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  IonToolbar = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  })], IonToolbar);\n  return IonToolbar;\n})();\n\nvar Config = /*#__PURE__*/function () {\n  function Config() {\n    _classCallCheck(this, Config);\n  }\n\n  _createClass(Config, [{\n    key: \"get\",\n    value: function get(key, fallback) {\n      var c = getConfig();\n\n      if (c) {\n        return c.get(key, fallback);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getBoolean\",\n    value: function getBoolean(key, fallback) {\n      var c = getConfig();\n\n      if (c) {\n        return c.getBoolean(key, fallback);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getNumber\",\n    value: function getNumber(key, fallback) {\n      var c = getConfig();\n\n      if (c) {\n        return c.getNumber(key, fallback);\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      console.warn(\"[DEPRECATION][Config]: The Config.set() method is deprecated and will be removed in Ionic Framework 6.0. Please see https://ionicframework.com/docs/angular/config for alternatives.\");\n      var c = getConfig();\n\n      if (c) {\n        c.set(key, value);\n      }\n    }\n  }]);\n\n  return Config;\n}();\n\nConfig.ɵfac = function Config_Factory(t) {\n  return new (t || Config)();\n};\n\nConfig.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: Config,\n  factory: function factory(t) {\n    return Config.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nConfig.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function Config_Factory() {\n    return new Config();\n  },\n  token: Config,\n  providedIn: \"root\"\n});\nvar ConfigToken = new InjectionToken('USERCONFIG');\n\nvar getConfig = function getConfig() {\n  if (typeof window !== 'undefined') {\n    var Ionic = window.Ionic;\n\n    if (Ionic && Ionic.config) {\n      return Ionic.config;\n    }\n  }\n\n  return null;\n};\n\nvar ɵ0$3 = getConfig;\n/**\n * @description\n * NavParams are an object that exists on a page and can contain data for that particular view.\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\n * option with a simple `get` method.\n *\n * @usage\n * ```ts\n * import { NavParams } from '@ionic/angular';\n *\n * export class MyClass{\n *\n *  constructor(navParams: NavParams){\n *    // userParams is an object we have in our nav-parameters\n *    navParams.get('userParams');\n *  }\n *\n * }\n * ```\n */\n\nvar NavParams = /*#__PURE__*/function () {\n  function NavParams() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, NavParams);\n\n    this.data = data;\n  }\n  /**\n   * Get the value of a nav-parameter for the current view\n   *\n   * ```ts\n   * import { NavParams } from 'ionic-angular';\n   *\n   * export class MyClass{\n   *  constructor(public navParams: NavParams){\n   *    // userParams is an object we have in our nav-parameters\n   *    this.navParams.get('userParams');\n   *  }\n   * }\n   * ```\n   *\n   * @param param Which param you want to look up\n   */\n\n\n  _createClass(NavParams, [{\n    key: \"get\",\n    value: function get(param) {\n      return this.data[param];\n    }\n  }]);\n\n  return NavParams;\n}();\n\nvar AngularDelegate = /*#__PURE__*/(function () {\n  var AngularDelegate = /*#__PURE__*/function () {\n    function AngularDelegate(zone, appRef) {\n      _classCallCheck(this, AngularDelegate);\n\n      this.zone = zone;\n      this.appRef = appRef;\n    }\n\n    _createClass(AngularDelegate, [{\n      key: \"create\",\n      value: function create(resolver, injector, location) {\n        return new AngularFrameworkDelegate(resolver, injector, location, this.appRef, this.zone);\n      }\n    }]);\n\n    return AngularDelegate;\n  }();\n\n  AngularDelegate.ɵfac = function AngularDelegate_Factory(t) {\n    return new (t || AngularDelegate)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef));\n  };\n\n  AngularDelegate.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: AngularDelegate,\n    factory: function factory(t) {\n      return AngularDelegate.ɵfac(t);\n    }\n  });\n  return AngularDelegate;\n})();\n\nvar AngularFrameworkDelegate = /*#__PURE__*/function () {\n  function AngularFrameworkDelegate(resolver, injector, location, appRef, zone) {\n    _classCallCheck(this, AngularFrameworkDelegate);\n\n    this.resolver = resolver;\n    this.injector = injector;\n    this.location = location;\n    this.appRef = appRef;\n    this.zone = zone;\n    this.elRefMap = new WeakMap();\n    this.elEventsMap = new WeakMap();\n  }\n\n  _createClass(AngularFrameworkDelegate, [{\n    key: \"attachViewToDom\",\n    value: function attachViewToDom(container, component, params, cssClasses) {\n      var _this6 = this;\n\n      return this.zone.run(function () {\n        return new Promise(function (resolve) {\n          var el = attachView(_this6.zone, _this6.resolver, _this6.injector, _this6.location, _this6.appRef, _this6.elRefMap, _this6.elEventsMap, container, component, params, cssClasses);\n          resolve(el);\n        });\n      });\n    }\n  }, {\n    key: \"removeViewFromDom\",\n    value: function removeViewFromDom(_container, component) {\n      var _this7 = this;\n\n      return this.zone.run(function () {\n        return new Promise(function (resolve) {\n          var componentRef = _this7.elRefMap.get(component);\n\n          if (componentRef) {\n            componentRef.destroy();\n\n            _this7.elRefMap.delete(component);\n\n            var unbindEvents = _this7.elEventsMap.get(component);\n\n            if (unbindEvents) {\n              unbindEvents();\n\n              _this7.elEventsMap.delete(component);\n            }\n          }\n\n          resolve();\n        });\n      });\n    }\n  }]);\n\n  return AngularFrameworkDelegate;\n}();\n\nvar attachView = function attachView(zone, resolver, injector, location, appRef, elRefMap, elEventsMap, container, component, params, cssClasses) {\n  var factory = resolver.resolveComponentFactory(component);\n  var childInjector = Injector.create({\n    providers: getProviders(params),\n    parent: injector\n  });\n  var componentRef = location ? location.createComponent(factory, location.length, childInjector) : factory.create(childInjector);\n  var instance = componentRef.instance;\n  var hostElement = componentRef.location.nativeElement;\n\n  if (params) {\n    Object.assign(instance, params);\n  }\n\n  if (cssClasses) {\n    var _iterator = _createForOfIteratorHelper(cssClasses),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var clazz = _step.value;\n        hostElement.classList.add(clazz);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  var unbindEvents = bindLifecycleEvents(zone, instance, hostElement);\n  container.appendChild(hostElement);\n\n  if (!location) {\n    appRef.attachView(componentRef.hostView);\n  }\n\n  componentRef.changeDetectorRef.reattach();\n  elRefMap.set(hostElement, componentRef);\n  elEventsMap.set(hostElement, unbindEvents);\n  return hostElement;\n};\n\nvar LIFECYCLES = [LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD];\n\nvar bindLifecycleEvents = function bindLifecycleEvents(zone, instance, element) {\n  return zone.run(function () {\n    var unregisters = LIFECYCLES.filter(function (eventName) {\n      return typeof instance[eventName] === 'function';\n    }).map(function (eventName) {\n      var handler = function handler(ev) {\n        return instance[eventName](ev.detail);\n      };\n\n      element.addEventListener(eventName, handler);\n      return function () {\n        return element.removeEventListener(eventName, handler);\n      };\n    });\n    return function () {\n      return unregisters.forEach(function (fn) {\n        return fn();\n      });\n    };\n  });\n};\n\nvar NavParamsToken = new InjectionToken('NavParamsToken');\n\nvar getProviders = function getProviders(params) {\n  return [{\n    provide: NavParamsToken,\n    useValue: params\n  }, {\n    provide: NavParams,\n    useFactory: provideNavParamsInjectable,\n    deps: [NavParamsToken]\n  }];\n};\n\nvar ɵ0$4 = getProviders;\n\nvar provideNavParamsInjectable = function provideNavParamsInjectable(params) {\n  return new NavParams(params);\n};\n\nvar ɵ1$2 = provideNavParamsInjectable;\n\nvar _insertView = function insertView(views, view, direction) {\n  if (direction === 'root') {\n    return setRoot(views, view);\n  } else if (direction === 'forward') {\n    return setForward(views, view);\n  } else {\n    return setBack(views, view);\n  }\n};\n\nvar setRoot = function setRoot(views, view) {\n  views = views.filter(function (v) {\n    return v.stackId !== view.stackId;\n  });\n  views.push(view);\n  return views;\n};\n\nvar ɵ0$5 = setRoot;\n\nvar setForward = function setForward(views, view) {\n  var index = views.indexOf(view);\n\n  if (index >= 0) {\n    views = views.filter(function (v) {\n      return v.stackId !== view.stackId || v.id <= view.id;\n    });\n  } else {\n    views.push(view);\n  }\n\n  return views;\n};\n\nvar ɵ1$3 = setForward;\n\nvar setBack = function setBack(views, view) {\n  var index = views.indexOf(view);\n\n  if (index >= 0) {\n    return views.filter(function (v) {\n      return v.stackId !== view.stackId || v.id <= view.id;\n    });\n  } else {\n    return setRoot(views, view);\n  }\n};\n\nvar ɵ2$1 = setBack;\n\nvar getUrl = function getUrl(router, activatedRoute) {\n  var urlTree = router.createUrlTree(['.'], {\n    relativeTo: activatedRoute\n  });\n  return router.serializeUrl(urlTree);\n};\n\nvar isTabSwitch = function isTabSwitch(enteringView, leavingView) {\n  if (!leavingView) {\n    return true;\n  }\n\n  return enteringView.stackId !== leavingView.stackId;\n};\n\nvar computeStackId = function computeStackId(prefixUrl, url) {\n  if (!prefixUrl) {\n    return undefined;\n  }\n\n  var segments = toSegments(url);\n\n  for (var i = 0; i < segments.length; i++) {\n    if (i >= prefixUrl.length) {\n      return segments[i];\n    }\n\n    if (segments[i] !== prefixUrl[i]) {\n      return undefined;\n    }\n  }\n\n  return undefined;\n};\n\nvar toSegments = function toSegments(path) {\n  return path.split('/').map(function (s) {\n    return s.trim();\n  }).filter(function (s) {\n    return s !== '';\n  });\n};\n\nvar destroyView = function destroyView(view) {\n  if (view) {\n    // TODO lifecycle event\n    view.ref.destroy();\n    view.unlistenEvents();\n  }\n};\n\nvar StackController = /*#__PURE__*/function () {\n  function StackController(tabsPrefix, containerEl, router, navCtrl, zone, location) {\n    _classCallCheck(this, StackController);\n\n    this.containerEl = containerEl;\n    this.router = router;\n    this.navCtrl = navCtrl;\n    this.zone = zone;\n    this.location = location;\n    this.views = [];\n    this.skipTransition = false;\n    this.nextId = 0;\n    this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;\n  }\n\n  _createClass(StackController, [{\n    key: \"createView\",\n    value: function createView(ref, activatedRoute) {\n      var url = getUrl(this.router, activatedRoute);\n      var element = ref && ref.location && ref.location.nativeElement;\n      var unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);\n      return {\n        id: this.nextId++,\n        stackId: computeStackId(this.tabsPrefix, url),\n        unlistenEvents: unlistenEvents,\n        element: element,\n        ref: ref,\n        url: url\n      };\n    }\n  }, {\n    key: \"getExistingView\",\n    value: function getExistingView(activatedRoute) {\n      var activatedUrlKey = getUrl(this.router, activatedRoute);\n      var view = this.views.find(function (vw) {\n        return vw.url === activatedUrlKey;\n      });\n\n      if (view) {\n        view.ref.changeDetectorRef.reattach();\n      }\n\n      return view;\n    }\n  }, {\n    key: \"setActive\",\n    value: function setActive(enteringView) {\n      var _this8 = this;\n\n      var consumeResult = this.navCtrl.consumeTransition();\n      var direction = consumeResult.direction,\n          animation = consumeResult.animation,\n          animationBuilder = consumeResult.animationBuilder;\n      var leavingView = this.activeView;\n      var tabSwitch = isTabSwitch(enteringView, leavingView);\n\n      if (tabSwitch) {\n        direction = 'back';\n        animation = undefined;\n      }\n\n      var viewsSnapshot = this.views.slice();\n      var currentNavigation;\n      var router = this.router; // Angular >= 7.2.0\n\n      if (router.getCurrentNavigation) {\n        currentNavigation = router.getCurrentNavigation(); // Angular < 7.2.0\n      } else if (router.navigations && router.navigations.value) {\n        currentNavigation = router.navigations.value;\n      }\n      /**\n       * If the navigation action\n       * sets `replaceUrl: true`\n       * then we need to make sure\n       * we remove the last item\n       * from our views stack\n       */\n\n\n      if (currentNavigation && currentNavigation.extras && currentNavigation.extras.replaceUrl) {\n        if (this.views.length > 0) {\n          this.views.splice(-1, 1);\n        }\n      }\n\n      var reused = this.views.includes(enteringView);\n      var views = this.insertView(enteringView, direction); // Trigger change detection before transition starts\n      // This will call ngOnInit() the first time too, just after the view\n      // was attached to the dom, but BEFORE the transition starts\n\n      if (!reused) {\n        enteringView.ref.changeDetectorRef.detectChanges();\n      }\n      /**\n       * If we are going back from a page that\n       * was presented using a custom animation\n       * we should default to using that\n       * unless the developer explicitly\n       * provided another animation.\n       */\n\n\n      var customAnimation = enteringView.animationBuilder;\n\n      if (animationBuilder === undefined && direction === 'back' && !tabSwitch && customAnimation !== undefined) {\n        animationBuilder = customAnimation;\n      }\n      /**\n       * Save any custom animation so that navigating\n       * back will use this custom animation by default.\n       */\n\n\n      if (leavingView) {\n        leavingView.animationBuilder = animationBuilder;\n      } // Wait until previous transitions finish\n\n\n      return this.zone.runOutsideAngular(function () {\n        return _this8.wait(function () {\n          // disconnect leaving page from change detection to\n          // reduce jank during the page transition\n          if (leavingView) {\n            leavingView.ref.changeDetectorRef.detach();\n          } // In case the enteringView is the same as the leavingPage we need to reattach()\n\n\n          enteringView.ref.changeDetectorRef.reattach();\n          return _this8.transition(enteringView, leavingView, animation, _this8.canGoBack(1), false, animationBuilder).then(function () {\n            return cleanupAsync(enteringView, views, viewsSnapshot, _this8.location);\n          }).then(function () {\n            return {\n              enteringView: enteringView,\n              direction: direction,\n              animation: animation,\n              tabSwitch: tabSwitch\n            };\n          });\n        });\n      });\n    }\n  }, {\n    key: \"canGoBack\",\n    value: function canGoBack(deep) {\n      var stackId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getActiveStackId();\n      return this.getStack(stackId).length > deep;\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(deep) {\n      var _this9 = this;\n\n      var stackId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getActiveStackId();\n      return this.zone.run(function () {\n        var views = _this9.getStack(stackId);\n\n        if (views.length <= deep) {\n          return Promise.resolve(false);\n        }\n\n        var view = views[views.length - deep - 1];\n        var url = view.url;\n        var viewSavedData = view.savedData;\n\n        if (viewSavedData) {\n          var primaryOutlet = viewSavedData.get('primary');\n\n          if (primaryOutlet && primaryOutlet.route && primaryOutlet.route._routerState && primaryOutlet.route._routerState.snapshot && primaryOutlet.route._routerState.snapshot.url) {\n            url = primaryOutlet.route._routerState.snapshot.url;\n          }\n        }\n\n        var _this9$navCtrl$consum = _this9.navCtrl.consumeTransition(),\n            animationBuilder = _this9$navCtrl$consum.animationBuilder;\n\n        return _this9.navCtrl.navigateBack(url, Object.assign({}, view.savedExtras, {\n          animation: animationBuilder\n        })).then(function () {\n          return true;\n        });\n      });\n    }\n  }, {\n    key: \"startBackTransition\",\n    value: function startBackTransition() {\n      var _this10 = this;\n\n      var leavingView = this.activeView;\n\n      if (leavingView) {\n        var views = this.getStack(leavingView.stackId);\n        var enteringView = views[views.length - 2];\n        var customAnimation = enteringView.animationBuilder;\n        return this.wait(function () {\n          return _this10.transition(enteringView, // entering view\n          leavingView, // leaving view\n          'back', _this10.canGoBack(2), true, customAnimation);\n        });\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"endBackTransition\",\n    value: function endBackTransition(shouldComplete) {\n      if (shouldComplete) {\n        this.skipTransition = true;\n        this.pop(1);\n      } else if (this.activeView) {\n        cleanup(this.activeView, this.views, this.views, this.location);\n      }\n    }\n  }, {\n    key: \"getLastUrl\",\n    value: function getLastUrl(stackId) {\n      var views = this.getStack(stackId);\n      return views.length > 0 ? views[views.length - 1] : undefined;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"getRootUrl\",\n    value: function getRootUrl(stackId) {\n      var views = this.getStack(stackId);\n      return views.length > 0 ? views[0] : undefined;\n    }\n  }, {\n    key: \"getActiveStackId\",\n    value: function getActiveStackId() {\n      return this.activeView ? this.activeView.stackId : undefined;\n    }\n  }, {\n    key: \"hasRunningTask\",\n    value: function hasRunningTask() {\n      return this.runningTask !== undefined;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.containerEl = undefined;\n      this.views.forEach(destroyView);\n      this.activeView = undefined;\n      this.views = [];\n    }\n  }, {\n    key: \"getStack\",\n    value: function getStack(stackId) {\n      return this.views.filter(function (v) {\n        return v.stackId === stackId;\n      });\n    }\n  }, {\n    key: \"insertView\",\n    value: function insertView(enteringView, direction) {\n      this.activeView = enteringView;\n      this.views = _insertView(this.views, enteringView, direction);\n      return this.views.slice();\n    }\n  }, {\n    key: \"transition\",\n    value: function transition(enteringView, leavingView, direction, showGoBack, progressAnimation, animationBuilder) {\n      if (this.skipTransition) {\n        this.skipTransition = false;\n        return Promise.resolve(false);\n      }\n\n      if (leavingView === enteringView) {\n        return Promise.resolve(false);\n      }\n\n      var enteringEl = enteringView ? enteringView.element : undefined;\n      var leavingEl = leavingView ? leavingView.element : undefined;\n      var containerEl = this.containerEl;\n\n      if (enteringEl && enteringEl !== leavingEl) {\n        enteringEl.classList.add('ion-page');\n        enteringEl.classList.add('ion-page-invisible');\n\n        if (enteringEl.parentElement !== containerEl) {\n          containerEl.appendChild(enteringEl);\n        }\n\n        if (containerEl.commit) {\n          return containerEl.commit(enteringEl, leavingEl, {\n            deepWait: true,\n            duration: direction === undefined ? 0 : undefined,\n            direction: direction,\n            showGoBack: showGoBack,\n            progressAnimation: progressAnimation,\n            animationBuilder: animationBuilder\n          });\n        }\n      }\n\n      return Promise.resolve(false);\n    }\n  }, {\n    key: \"wait\",\n    value: function wait(task) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this11 = this;\n\n        var promise;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.runningTask !== undefined)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.runningTask;\n\n              case 3:\n                this.runningTask = undefined;\n\n              case 4:\n                promise = this.runningTask = task();\n                promise.finally(function () {\n                  return _this11.runningTask = undefined;\n                });\n                return _context2.abrupt(\"return\", promise);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }]);\n\n  return StackController;\n}();\n\nvar cleanupAsync = function cleanupAsync(activeRoute, views, viewsSnapshot, location) {\n  if (typeof requestAnimationFrame === 'function') {\n    return new Promise(function (resolve) {\n      requestAnimationFrame(function () {\n        cleanup(activeRoute, views, viewsSnapshot, location);\n        resolve();\n      });\n    });\n  }\n\n  return Promise.resolve();\n};\n\nvar ɵ0$6 = cleanupAsync;\n\nvar cleanup = function cleanup(activeRoute, views, viewsSnapshot, location) {\n  viewsSnapshot.filter(function (view) {\n    return !views.includes(view);\n  }).forEach(destroyView);\n  views.forEach(function (view) {\n    /**\n     * In the event that a user navigated multiple\n     * times in rapid succession, we want to make sure\n     * we don't pre-emptively detach a view while\n     * it is in mid-transition.\n     *\n     * In this instance we also do not care about query\n     * params or fragments as it will be the same view regardless\n     */\n    var locationWithoutParams = location.path().split('?')[0];\n    var locationWithoutFragment = locationWithoutParams.split('#')[0];\n\n    if (view !== activeRoute && view.url !== locationWithoutFragment) {\n      var element = view.element;\n      element.setAttribute('aria-hidden', 'true');\n      element.classList.add('ion-page-hidden');\n      view.ref.changeDetectorRef.detach();\n    }\n  });\n};\n\nvar ɵ1$4 = cleanup;\nvar IonRouterOutlet = /*#__PURE__*/(function () {\n  var IonRouterOutlet = /*#__PURE__*/function () {\n    function IonRouterOutlet(parentContexts, location, resolver, name, tabs, config, navCtrl, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\n      _classCallCheck(this, IonRouterOutlet);\n\n      this.parentContexts = parentContexts;\n      this.location = location;\n      this.resolver = resolver;\n      this.config = config;\n      this.navCtrl = navCtrl;\n      this.parentOutlet = parentOutlet;\n      this.activated = null;\n      this.activatedView = null;\n      this._activatedRoute = null; // Maintain map of activated route proxies for each component instance\n\n      this.proxyMap = new WeakMap(); // Keep the latest activated route in a subject for the proxy routes to switch map to\n\n      this.currentActivatedRoute$ = new BehaviorSubject(null);\n      this.stackEvents = new EventEmitter();\n      this.activateEvents = new EventEmitter();\n      this.deactivateEvents = new EventEmitter();\n      this.nativeEl = elementRef.nativeElement;\n      this.name = name || PRIMARY_OUTLET;\n      this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;\n      this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, navCtrl, zone, commonLocation);\n      parentContexts.onChildOutletCreated(this.name, this);\n    }\n\n    _createClass(IonRouterOutlet, [{\n      key: \"animation\",\n      set: function set(animation) {\n        this.nativeEl.animation = animation;\n      }\n    }, {\n      key: \"animated\",\n      set: function set(animated) {\n        this.nativeEl.animated = animated;\n      }\n    }, {\n      key: \"swipeGesture\",\n      set: function set(swipe) {\n        var _this12 = this;\n\n        this._swipeGesture = swipe;\n        this.nativeEl.swipeHandler = swipe ? {\n          canStart: function canStart() {\n            return _this12.stackCtrl.canGoBack(1) && !_this12.stackCtrl.hasRunningTask();\n          },\n          onStart: function onStart() {\n            return _this12.stackCtrl.startBackTransition();\n          },\n          onEnd: function onEnd(shouldContinue) {\n            return _this12.stackCtrl.endBackTransition(shouldContinue);\n          }\n        } : undefined;\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.stackCtrl.destroy();\n      }\n    }, {\n      key: \"getContext\",\n      value: function getContext() {\n        return this.parentContexts.getContext(this.name);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this13 = this;\n\n        if (!this.activated) {\n          // If the outlet was not instantiated at the time the route got activated we need to populate\n          // the outlet when it is initialized (ie inside a NgIf)\n          var context = this.getContext();\n\n          if (context && context.route) {\n            this.activateWith(context.route, context.resolver || null);\n          }\n        }\n\n        new Promise(function (resolve) {\n          return componentOnReady(_this13.nativeEl, resolve);\n        }).then(function () {\n          if (_this13._swipeGesture === undefined) {\n            _this13.swipeGesture = _this13.config.getBoolean('swipeBackEnabled', _this13.nativeEl.mode === 'ios');\n          }\n        });\n      }\n    }, {\n      key: \"isActivated\",\n      get: function get() {\n        return !!this.activated;\n      }\n    }, {\n      key: \"component\",\n      get: function get() {\n        if (!this.activated) {\n          throw new Error('Outlet is not activated');\n        }\n\n        return this.activated.instance;\n      }\n    }, {\n      key: \"activatedRoute\",\n      get: function get() {\n        if (!this.activated) {\n          throw new Error('Outlet is not activated');\n        }\n\n        return this._activatedRoute;\n      }\n    }, {\n      key: \"activatedRouteData\",\n      get: function get() {\n        if (this._activatedRoute) {\n          return this._activatedRoute.snapshot.data;\n        }\n\n        return {};\n      }\n      /**\n       * Called when the `RouteReuseStrategy` instructs to detach the subtree\n       */\n\n    }, {\n      key: \"detach\",\n      value: function detach() {\n        throw new Error('incompatible reuse strategy');\n      }\n      /**\n       * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n       */\n\n    }, {\n      key: \"attach\",\n      value: function attach(_ref, _activatedRoute) {\n        throw new Error('incompatible reuse strategy');\n      }\n    }, {\n      key: \"deactivate\",\n      value: function deactivate() {\n        if (this.activated) {\n          if (this.activatedView) {\n            var context = this.getContext();\n            this.activatedView.savedData = new Map(context.children['contexts']);\n            /**\n             * Angular v11.2.10 introduced a change\n             * where this route context is cleared out when\n             * a router-outlet is deactivated, However,\n             * we need this route information in order to\n             * return a user back to the correct tab when\n             * leaving and then going back to the tab context.\n             */\n\n            var primaryOutlet = this.activatedView.savedData.get('primary');\n\n            if (primaryOutlet && context.route) {\n              primaryOutlet.route = Object.assign({}, context.route);\n            }\n            /**\n             * Ensure we are saving the NavigationExtras\n             * data otherwise it will be lost\n             */\n\n\n            this.activatedView.savedExtras = {};\n\n            if (context.route) {\n              var contextSnapshot = context.route.snapshot;\n              this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;\n              this.activatedView.savedExtras.fragment = contextSnapshot.fragment;\n            }\n          }\n\n          var c = this.component;\n          this.activatedView = null;\n          this.activated = null;\n          this._activatedRoute = null;\n          this.deactivateEvents.emit(c);\n        }\n      }\n    }, {\n      key: \"activateWith\",\n      value: function activateWith(activatedRoute, resolver) {\n        var _this14 = this;\n\n        if (this.isActivated) {\n          throw new Error('Cannot activate an already activated outlet');\n        }\n\n        this._activatedRoute = activatedRoute;\n        var cmpRef;\n        var enteringView = this.stackCtrl.getExistingView(activatedRoute);\n\n        if (enteringView) {\n          cmpRef = this.activated = enteringView.ref;\n          var saved = enteringView.savedData;\n\n          if (saved) {\n            // self-restore\n            var context = this.getContext();\n            context.children['contexts'] = saved;\n          } // Updated activated route proxy for this component\n\n\n          this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);\n        } else {\n          var snapshot = activatedRoute._futureSnapshot;\n          var component = snapshot.routeConfig.component;\n          resolver = resolver || this.resolver;\n          var factory = resolver.resolveComponentFactory(component);\n          var childContexts = this.parentContexts.getOrCreateContext(this.name).children; // We create an activated route proxy object that will maintain future updates for this component\n          // over its lifecycle in the stack.\n\n          var component$ = new BehaviorSubject(null);\n          var activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);\n          var injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);\n          cmpRef = this.activated = this.location.createComponent(factory, this.location.length, injector); // Once the component is created we can push it to our local subject supplied to the proxy\n\n          component$.next(cmpRef.instance); // Calling `markForCheck` to make sure we will run the change detection when the\n          // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n\n          enteringView = this.stackCtrl.createView(this.activated, activatedRoute); // Store references to the proxy by component\n\n          this.proxyMap.set(cmpRef.instance, activatedRouteProxy);\n          this.currentActivatedRoute$.next({\n            component: cmpRef.instance,\n            activatedRoute: activatedRoute\n          });\n        }\n\n        this.activatedView = enteringView;\n        this.stackCtrl.setActive(enteringView).then(function (data) {\n          _this14.navCtrl.setTopOutlet(_this14);\n\n          _this14.activateEvents.emit(cmpRef.instance);\n\n          _this14.stackEvents.emit(data);\n        });\n      }\n      /**\n       * Returns `true` if there are pages in the stack to go back.\n       */\n\n    }, {\n      key: \"canGoBack\",\n      value: function canGoBack() {\n        var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var stackId = arguments.length > 1 ? arguments[1] : undefined;\n        return this.stackCtrl.canGoBack(deep, stackId);\n      }\n      /**\n       * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n       */\n\n    }, {\n      key: \"pop\",\n      value: function pop() {\n        var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var stackId = arguments.length > 1 ? arguments[1] : undefined;\n        return this.stackCtrl.pop(deep, stackId);\n      }\n      /**\n       * Returns the URL of the active page of each stack.\n       */\n\n    }, {\n      key: \"getLastUrl\",\n      value: function getLastUrl(stackId) {\n        var active = this.stackCtrl.getLastUrl(stackId);\n        return active ? active.url : undefined;\n      }\n      /**\n       * Returns the RouteView of the active page of each stack.\n       * @internal\n       */\n\n    }, {\n      key: \"getLastRouteView\",\n      value: function getLastRouteView(stackId) {\n        return this.stackCtrl.getLastUrl(stackId);\n      }\n      /**\n       * Returns the root view in the tab stack.\n       * @internal\n       */\n\n    }, {\n      key: \"getRootView\",\n      value: function getRootView(stackId) {\n        return this.stackCtrl.getRootUrl(stackId);\n      }\n      /**\n       * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n       */\n\n    }, {\n      key: \"getActiveStackId\",\n      value: function getActiveStackId() {\n        return this.stackCtrl.getActiveStackId();\n      }\n      /**\n       * Since the activated route can change over the life time of a component in an ion router outlet, we create\n       * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n       */\n\n    }, {\n      key: \"createActivatedRouteProxy\",\n      value: function createActivatedRouteProxy(component$, activatedRoute) {\n        var proxy = new ActivatedRoute();\n        proxy._futureSnapshot = activatedRoute._futureSnapshot;\n        proxy._routerState = activatedRoute._routerState;\n        proxy.snapshot = activatedRoute.snapshot;\n        proxy.outlet = activatedRoute.outlet;\n        proxy.component = activatedRoute.component; // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates\n\n        proxy._paramMap = this.proxyObservable(component$, 'paramMap');\n        proxy._queryParamMap = this.proxyObservable(component$, 'queryParamMap');\n        proxy.url = this.proxyObservable(component$, 'url');\n        proxy.params = this.proxyObservable(component$, 'params');\n        proxy.queryParams = this.proxyObservable(component$, 'queryParams');\n        proxy.fragment = this.proxyObservable(component$, 'fragment');\n        proxy.data = this.proxyObservable(component$, 'data');\n        return proxy;\n      }\n      /**\n       * Create a wrapped observable that will switch to the latest activated route matched by the given component\n       */\n\n    }, {\n      key: \"proxyObservable\",\n      value: function proxyObservable(component$, path) {\n        var _this15 = this;\n\n        return component$.pipe( // First wait until the component instance is pushed\n        filter(function (component) {\n          return !!component;\n        }), switchMap(function (component) {\n          return _this15.currentActivatedRoute$.pipe(filter(function (current) {\n            return current !== null && current.component === component;\n          }), switchMap(function (current) {\n            return current && current.activatedRoute[path];\n          }), distinctUntilChanged());\n        }));\n      }\n      /**\n       * Updates the activated route proxy for the given component to the new incoming router state\n       */\n\n    }, {\n      key: \"updateActivatedRouteProxy\",\n      value: function updateActivatedRouteProxy(component, activatedRoute) {\n        var proxy = this.proxyMap.get(component);\n\n        if (!proxy) {\n          throw new Error(\"Could not find activated route proxy for view\");\n        }\n\n        proxy._futureSnapshot = activatedRoute._futureSnapshot;\n        proxy._routerState = activatedRoute._routerState;\n        proxy.snapshot = activatedRoute.snapshot;\n        proxy.outlet = activatedRoute.outlet;\n        proxy.component = activatedRoute.component;\n        this.currentActivatedRoute$.next({\n          component: component,\n          activatedRoute: activatedRoute\n        });\n      }\n    }]);\n\n    return IonRouterOutlet;\n  }();\n\n  IonRouterOutlet.ɵfac = function IonRouterOutlet_Factory(t) {\n    return new (t || IonRouterOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ChildrenOutletContexts), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinjectAttribute('name'), ɵngcc0.ɵɵinjectAttribute('tabs'), ɵngcc0.ɵɵdirectiveInject(Config), ɵngcc0.ɵɵdirectiveInject(NavController), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Location), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(IonRouterOutlet, 12));\n  };\n\n  IonRouterOutlet.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: IonRouterOutlet,\n    selectors: [[\"ion-router-outlet\"]],\n    inputs: {\n      animated: \"animated\",\n      animation: \"animation\",\n      swipeGesture: \"swipeGesture\"\n    },\n    outputs: {\n      stackEvents: \"stackEvents\",\n      activateEvents: \"activate\",\n      deactivateEvents: \"deactivate\"\n    },\n    exportAs: [\"outlet\"]\n  });\n\n  __decorate([Output()], IonRouterOutlet.prototype, \"stackEvents\", void 0);\n\n  __decorate([Output('activate')], IonRouterOutlet.prototype, \"activateEvents\", void 0);\n\n  __decorate([Output('deactivate')], IonRouterOutlet.prototype, \"deactivateEvents\", void 0);\n\n  IonRouterOutlet = __decorate([__param(3, Attribute('name')), __param(4, Optional()), __param(4, Attribute('tabs')), __param(12, SkipSelf()), __param(12, Optional())], IonRouterOutlet);\n  return IonRouterOutlet;\n})();\n\nvar OutletInjector = /*#__PURE__*/function () {\n  function OutletInjector(route, childContexts, parent) {\n    _classCallCheck(this, OutletInjector);\n\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n\n  _createClass(OutletInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      if (token === ActivatedRoute) {\n        return this.route;\n      }\n\n      if (token === ChildrenOutletContexts) {\n        return this.childContexts;\n      } // tslint:disable-next-line\n\n\n      return this.parent.get(token, notFoundValue);\n    }\n  }]);\n\n  return OutletInjector;\n}();\n\nvar IonTabs = /*#__PURE__*/(function () {\n  var IonTabs = /*#__PURE__*/function () {\n    function IonTabs(navCtrl) {\n      _classCallCheck(this, IonTabs);\n\n      this.navCtrl = navCtrl;\n      this.ionTabsWillChange = new EventEmitter();\n      this.ionTabsDidChange = new EventEmitter();\n    }\n    /**\n     * @internal\n     */\n\n\n    _createClass(IonTabs, [{\n      key: \"onPageSelected\",\n      value: function onPageSelected(detail) {\n        var stackId = detail.enteringView.stackId;\n\n        if (detail.tabSwitch && stackId !== undefined) {\n          if (this.tabBar) {\n            this.tabBar.selectedTab = stackId;\n          }\n\n          this.ionTabsWillChange.emit({\n            tab: stackId\n          });\n          this.ionTabsDidChange.emit({\n            tab: stackId\n          });\n        }\n      }\n      /**\n       * When a tab button is clicked, there are several scenarios:\n       * 1. If the selected tab is currently active (the tab button has been clicked\n       *    again), then it should go to the root view for that tab.\n       *\n       *   a. Get the saved root view from the router outlet. If the saved root view\n       *      matches the tabRootUrl, set the route view to this view including the\n       *      navigation extras.\n       *   b. If the saved root view from the router outlet does\n       *      not match, navigate to the tabRootUrl. No navigation extras are\n       *      included.\n       *\n       * 2. If the current tab tab is not currently selected, get the last route\n       *    view from the router outlet.\n       *\n       *   a. If the last route view exists, navigate to that view including any\n       *      navigation extras\n       *   b. If the last route view doesn't exist, then navigate\n       *      to the default tabRootUrl\n       */\n\n    }, {\n      key: \"select\",\n      value: function select(tabOrEvent) {\n        var isTabString = typeof tabOrEvent === 'string';\n        var tab = isTabString ? tabOrEvent : tabOrEvent.detail.tab;\n        var alreadySelected = this.outlet.getActiveStackId() === tab;\n        var tabRootUrl = \"\".concat(this.outlet.tabsPrefix, \"/\").concat(tab);\n        /**\n         * If this is a nested tab, prevent the event\n         * from bubbling otherwise the outer tabs\n         * will respond to this event too, causing\n         * the app to get directed to the wrong place.\n         */\n\n        if (!isTabString) {\n          tabOrEvent.stopPropagation();\n        }\n\n        if (alreadySelected) {\n          var activeStackId = this.outlet.getActiveStackId();\n          var activeView = this.outlet.getLastRouteView(activeStackId); // If on root tab, do not navigate to root tab again\n\n          if (activeView.url === tabRootUrl) {\n            return;\n          }\n\n          var rootView = this.outlet.getRootView(tab);\n          var navigationExtras = rootView && tabRootUrl === rootView.url && rootView.savedExtras;\n          return this.navCtrl.navigateRoot(tabRootUrl, Object.assign({}, navigationExtras, {\n            animated: true,\n            animationDirection: 'back'\n          }));\n        } else {\n          var lastRoute = this.outlet.getLastRouteView(tab);\n          /**\n           * If there is a lastRoute, goto that, otherwise goto the fallback url of the\n           * selected tab\n           */\n\n          var url = lastRoute && lastRoute.url || tabRootUrl;\n\n          var _navigationExtras = lastRoute && lastRoute.savedExtras;\n\n          return this.navCtrl.navigateRoot(url, Object.assign({}, _navigationExtras, {\n            animated: true,\n            animationDirection: 'back'\n          }));\n        }\n      }\n    }, {\n      key: \"getSelected\",\n      value: function getSelected() {\n        return this.outlet.getActiveStackId();\n      }\n    }]);\n\n    return IonTabs;\n  }();\n\n  IonTabs.ɵfac = function IonTabs_Factory(t) {\n    return new (t || IonTabs)(ɵngcc0.ɵɵdirectiveInject(NavController));\n  };\n\n  IonTabs.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonTabs,\n    selectors: [[\"ion-tabs\"]],\n    contentQueries: function IonTabs_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, IonTabBar, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabBar = _t.first);\n      }\n    },\n    viewQuery: function IonTabs_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c1, 5, IonRouterOutlet);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.outlet = _t.first);\n      }\n    },\n    hostBindings: function IonTabs_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"ionTabButtonClick\", function IonTabs_ionTabButtonClick_HostBindingHandler($event) {\n          return ctx.select($event);\n        });\n      }\n    },\n    outputs: {\n      ionTabsWillChange: \"ionTabsWillChange\",\n      ionTabsDidChange: \"ionTabsDidChange\"\n    },\n    ngContentSelectors: _c3,\n    decls: 5,\n    vars: 0,\n    consts: [[1, \"tabs-inner\"], [\"tabs\", \"true\", 3, \"stackEvents\"], [\"outlet\", \"\"]],\n    template: function IonTabs_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c2);\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(2, \"ion-router-outlet\", 1, 2);\n        ɵngcc0.ɵɵlistener(\"stackEvents\", function IonTabs_Template_ion_router_outlet_stackEvents_2_listener($event) {\n          return ctx.onPageSelected($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵprojection(4, 1);\n      }\n    },\n    directives: [IonRouterOutlet],\n    styles: [\"[_nghost-%COMP%] {\\n      display: flex;\\n      position: absolute;\\n      top: 0;\\n      left: 0;\\n      right: 0;\\n      bottom: 0;\\n\\n      flex-direction: column;\\n\\n      width: 100%;\\n      height: 100%;\\n\\n      contain: layout size style;\\n      z-index: $z-index-page-container;\\n    }\\n    .tabs-inner[_ngcontent-%COMP%] {\\n      position: relative;\\n\\n      flex: 1;\\n\\n      contain: layout size style;\\n    }\"]\n  });\n\n  __decorate([ViewChild('outlet', {\n    read: IonRouterOutlet,\n    static: false\n  })], IonTabs.prototype, \"outlet\", void 0);\n\n  __decorate([ContentChild(IonTabBar, {\n    static: false\n  })], IonTabs.prototype, \"tabBar\", void 0);\n\n  __decorate([Output()], IonTabs.prototype, \"ionTabsWillChange\", void 0);\n\n  __decorate([Output()], IonTabs.prototype, \"ionTabsDidChange\", void 0);\n\n  __decorate([HostListener('ionTabButtonClick', ['$event'])], IonTabs.prototype, \"select\", null);\n\n  return IonTabs;\n})();\nvar IonBackButtonDelegate = /*#__PURE__*/(function () {\n  var IonBackButtonDelegate = /*#__PURE__*/function () {\n    function IonBackButtonDelegate(routerOutlet, navCtrl, config) {\n      _classCallCheck(this, IonBackButtonDelegate);\n\n      this.routerOutlet = routerOutlet;\n      this.navCtrl = navCtrl;\n      this.config = config;\n    }\n    /**\n     * @internal\n     */\n\n\n    _createClass(IonBackButtonDelegate, [{\n      key: \"onClick\",\n      value: function onClick(ev) {\n        var defaultHref = this.defaultHref || this.config.get('backButtonDefaultHref');\n\n        if (this.routerOutlet && this.routerOutlet.canGoBack()) {\n          this.navCtrl.setDirection('back', undefined, undefined, this.routerAnimation);\n          this.routerOutlet.pop();\n          ev.preventDefault();\n        } else if (defaultHref != null) {\n          this.navCtrl.navigateBack(defaultHref, {\n            animation: this.routerAnimation\n          });\n          ev.preventDefault();\n        }\n      }\n    }]);\n\n    return IonBackButtonDelegate;\n  }();\n\n  IonBackButtonDelegate.ɵfac = function IonBackButtonDelegate_Factory(t) {\n    return new (t || IonBackButtonDelegate)(ɵngcc0.ɵɵdirectiveInject(IonRouterOutlet, 8), ɵngcc0.ɵɵdirectiveInject(NavController), ɵngcc0.ɵɵdirectiveInject(Config));\n  };\n\n  IonBackButtonDelegate.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: IonBackButtonDelegate,\n    selectors: [[\"ion-back-button\"]],\n    hostBindings: function IonBackButtonDelegate_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function IonBackButtonDelegate_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      defaultHref: \"defaultHref\",\n      routerAnimation: \"routerAnimation\"\n    }\n  });\n\n  __decorate([HostListener('click', ['$event'])], IonBackButtonDelegate.prototype, \"onClick\", null);\n\n  IonBackButtonDelegate = __decorate([__param(0, Optional())], IonBackButtonDelegate);\n  return IonBackButtonDelegate;\n})();\nvar NavDelegate = /*#__PURE__*/(function () {\n  var NavDelegate = function NavDelegate(ref, resolver, injector, angularDelegate, location) {\n    _classCallCheck(this, NavDelegate);\n\n    this.el = ref.nativeElement;\n    ref.nativeElement.delegate = angularDelegate.create(resolver, injector, location);\n    proxyOutputs(this, this.el, ['ionNavDidChange', 'ionNavWillChange']);\n  };\n\n  NavDelegate.ɵfac = function NavDelegate_Factory(t) {\n    return new (t || NavDelegate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(AngularDelegate), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  NavDelegate.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NavDelegate,\n    selectors: [[\"ion-nav\"]]\n  });\n  NavDelegate = __decorate([ProxyCmp({\n    inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'],\n    methods: ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious']\n  })], NavDelegate);\n  return NavDelegate;\n})();\nvar RouterLinkDelegate = /*#__PURE__*/(function () {\n  var RouterLinkDelegate = /*#__PURE__*/function () {\n    function RouterLinkDelegate(locationStrategy, navCtrl, elementRef, router, routerLink) {\n      _classCallCheck(this, RouterLinkDelegate);\n\n      this.locationStrategy = locationStrategy;\n      this.navCtrl = navCtrl;\n      this.elementRef = elementRef;\n      this.router = router;\n      this.routerLink = routerLink;\n      this.routerDirection = 'forward';\n    }\n\n    _createClass(RouterLinkDelegate, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.updateTargetUrlAndHref();\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges() {\n        this.updateTargetUrlAndHref();\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.subscription) {\n          this.subscription.unsubscribe();\n        }\n      }\n    }, {\n      key: \"updateTargetUrlAndHref\",\n      value: function updateTargetUrlAndHref() {\n        if (this.routerLink) {\n          var href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n          this.elementRef.nativeElement.href = href;\n        }\n      }\n      /**\n       * @internal\n       */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick(ev) {\n        this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n        ev.preventDefault();\n      }\n    }]);\n\n    return RouterLinkDelegate;\n  }();\n\n  RouterLinkDelegate.ɵfac = function RouterLinkDelegate_Factory(t) {\n    return new (t || RouterLinkDelegate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LocationStrategy), ɵngcc0.ɵɵdirectiveInject(NavController), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.RouterLink, 8));\n  };\n\n  RouterLinkDelegate.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: RouterLinkDelegate,\n    selectors: [[\"\", \"routerLink\", \"\"]],\n    hostBindings: function RouterLinkDelegate_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function RouterLinkDelegate_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      routerDirection: \"routerDirection\",\n      routerAnimation: \"routerAnimation\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([HostListener('click', ['$event'])], RouterLinkDelegate.prototype, \"onClick\", null);\n\n  RouterLinkDelegate = __decorate([__param(4, Optional())], RouterLinkDelegate);\n  /**\n   * @hidden\n   */\n\n  return RouterLinkDelegate;\n})();\nvar VirtualFooter = /*#__PURE__*/(function () {\n  var VirtualFooter = function VirtualFooter(templateRef) {\n    _classCallCheck(this, VirtualFooter);\n\n    this.templateRef = templateRef;\n  };\n\n  VirtualFooter.ɵfac = function VirtualFooter_Factory(t) {\n    return new (t || VirtualFooter)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  VirtualFooter.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: VirtualFooter,\n    selectors: [[\"\", \"virtualFooter\", \"\"]]\n  });\n  return VirtualFooter;\n})();\n\n/**\n * @hidden\n */\nvar VirtualHeader = /*#__PURE__*/(function () {\n  var VirtualHeader = function VirtualHeader(templateRef) {\n    _classCallCheck(this, VirtualHeader);\n\n    this.templateRef = templateRef;\n  };\n\n  VirtualHeader.ɵfac = function VirtualHeader_Factory(t) {\n    return new (t || VirtualHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  VirtualHeader.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: VirtualHeader,\n    selectors: [[\"\", \"virtualHeader\", \"\"]]\n  });\n  return VirtualHeader;\n})();\n\n/**\n * @hidden\n */\nvar VirtualItem = /*#__PURE__*/(function () {\n  var VirtualItem = function VirtualItem(templateRef, viewContainer) {\n    _classCallCheck(this, VirtualItem);\n\n    this.templateRef = templateRef;\n    this.viewContainer = viewContainer;\n  };\n\n  VirtualItem.ɵfac = function VirtualItem_Factory(t) {\n    return new (t || VirtualItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  VirtualItem.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: VirtualItem,\n    selectors: [[\"\", \"virtualItem\", \"\"]]\n  });\n  return VirtualItem;\n})();\nvar IonVirtualScroll = /*#__PURE__*/(function () {\n  var IonVirtualScroll = /*#__PURE__*/function () {\n    function IonVirtualScroll(z, iterableDiffers, elementRef) {\n      _classCallCheck(this, IonVirtualScroll);\n\n      this.z = z;\n      this.iterableDiffers = iterableDiffers;\n      this.refMap = new WeakMap();\n      this.el = elementRef.nativeElement;\n      this.el.nodeRender = this.nodeRender.bind(this);\n    }\n\n    _createClass(IonVirtualScroll, [{\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        if (this.trackBy && 'items' in changes) {\n          // React on virtualScroll changes only once all inputs have been initialized\n          var value = changes['items'].currentValue;\n\n          if (this.differ === undefined && value != null) {\n            try {\n              this.differ = this.iterableDiffers.find(value).create(this.trackBy);\n            } catch (e) {\n              throw new Error(\"Cannot find a differ supporting object '\".concat(value, \"'. VirtualScroll only supports binding to Iterables such as Arrays.\"));\n            }\n          }\n        }\n      }\n    }, {\n      key: \"ngDoCheck\",\n      value: function ngDoCheck() {\n        // and if there actually are changes\n        var changes = this.differ !== undefined && this.items ? this.differ.diff(this.items) : null;\n\n        if (changes === null) {\n          return;\n        } // TODO: optimize\n\n\n        this.checkRange(0);\n      }\n    }, {\n      key: \"nodeRender\",\n      value: function nodeRender(el, cell, index) {\n        var _this16 = this;\n\n        return this.z.run(function () {\n          var node;\n\n          if (!el) {\n            node = _this16.itmTmp.viewContainer.createEmbeddedView(_this16.getComponent(cell.type), {\n              $implicit: cell.value,\n              index: index\n            }, index);\n            el = getElement(node);\n\n            _this16.refMap.set(el, node);\n          } else {\n            node = _this16.refMap.get(el);\n            var ctx = node.context;\n            ctx.$implicit = cell.value;\n            ctx.index = cell.index;\n          } // run sync change detections\n\n\n          node.detectChanges();\n          return el;\n        });\n      }\n    }, {\n      key: \"getComponent\",\n      value: function getComponent(type) {\n        switch (type) {\n          case 'item':\n            return this.itmTmp.templateRef;\n\n          case 'header':\n            return this.hdrTmp.templateRef;\n\n          case 'footer':\n            return this.ftrTmp.templateRef;\n        }\n\n        throw new Error('template for virtual item was not provided');\n      }\n    }]);\n\n    return IonVirtualScroll;\n  }();\n\n  IonVirtualScroll.ɵfac = function IonVirtualScroll_Factory(t) {\n    return new (t || IonVirtualScroll)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  IonVirtualScroll.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: IonVirtualScroll,\n    selectors: [[\"ion-virtual-scroll\"]],\n    contentQueries: function IonVirtualScroll_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, VirtualItem, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, VirtualHeader, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, VirtualFooter, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itmTmp = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hdrTmp = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ftrTmp = _t.first);\n      }\n    },\n    inputs: {\n      approxItemHeight: \"approxItemHeight\",\n      approxHeaderHeight: \"approxHeaderHeight\",\n      approxFooterHeight: \"approxFooterHeight\",\n      headerFn: \"headerFn\",\n      footerFn: \"footerFn\",\n      items: \"items\",\n      itemHeight: \"itemHeight\",\n      headerHeight: \"headerHeight\",\n      footerHeight: \"footerHeight\",\n      trackBy: \"trackBy\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function IonVirtualScroll_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([ContentChild(VirtualItem, {\n    static: false\n  })], IonVirtualScroll.prototype, \"itmTmp\", void 0);\n\n  __decorate([ContentChild(VirtualHeader, {\n    static: false\n  })], IonVirtualScroll.prototype, \"hdrTmp\", void 0);\n\n  __decorate([ContentChild(VirtualFooter, {\n    static: false\n  })], IonVirtualScroll.prototype, \"ftrTmp\", void 0);\n\n  IonVirtualScroll = __decorate([ProxyCmp({\n    inputs: ['approxItemHeight', 'approxHeaderHeight', 'approxFooterHeight', 'headerFn', 'footerFn', 'items', 'itemHeight', 'headerHeight', 'footerHeight'],\n    methods: ['checkEnd', 'checkRange', 'positionForItem']\n  })], IonVirtualScroll);\n  return IonVirtualScroll;\n})();\n\nvar getElement = function getElement(view) {\n  var rootNodes = view.rootNodes;\n\n  for (var i = 0; i < rootNodes.length; i++) {\n    if (rootNodes[i].nodeType === 1) {\n      return rootNodes[i];\n    }\n  }\n\n  throw new Error('virtual element was not created');\n};\n\nvar ɵ0$7 = getElement;\n\nvar OverlayBaseController = /*#__PURE__*/function () {\n  function OverlayBaseController(ctrl) {\n    _classCallCheck(this, OverlayBaseController);\n\n    this.ctrl = ctrl;\n  }\n  /**\n   * Creates a new overlay\n   */\n\n\n  _createClass(OverlayBaseController, [{\n    key: \"create\",\n    value: function create(opts) {\n      // TODO: next major release opts is not optional\n      return this.ctrl.create(opts || {});\n    }\n    /**\n     * When `id` is not provided, it dismisses the top overlay.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function dismiss(data, role, id) {\n      return this.ctrl.dismiss(data, role, id);\n    }\n    /**\n     * Returns the top overlay.\n     */\n\n  }, {\n    key: \"getTop\",\n    value: function getTop() {\n      return this.ctrl.getTop();\n    }\n  }]);\n\n  return OverlayBaseController;\n}();\n\nvar ActionSheetController = /*#__PURE__*/function (_OverlayBaseControlle) {\n  _inherits(ActionSheetController, _OverlayBaseControlle);\n\n  var _super6 = _createSuper(ActionSheetController);\n\n  function ActionSheetController() {\n    _classCallCheck(this, ActionSheetController);\n\n    return _super6.call(this, actionSheetController);\n  }\n\n  return ActionSheetController;\n}(OverlayBaseController);\n\nActionSheetController.ɵfac = function ActionSheetController_Factory(t) {\n  return new (t || ActionSheetController)();\n};\n\nActionSheetController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: ActionSheetController,\n  factory: function factory(t) {\n    return ActionSheetController.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nActionSheetController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function ActionSheetController_Factory() {\n    return new ActionSheetController();\n  },\n  token: ActionSheetController,\n  providedIn: \"root\"\n});\n\nvar AlertController = /*#__PURE__*/function (_OverlayBaseControlle2) {\n  _inherits(AlertController, _OverlayBaseControlle2);\n\n  var _super7 = _createSuper(AlertController);\n\n  function AlertController() {\n    _classCallCheck(this, AlertController);\n\n    return _super7.call(this, alertController);\n  }\n\n  return AlertController;\n}(OverlayBaseController);\n\nAlertController.ɵfac = function AlertController_Factory(t) {\n  return new (t || AlertController)();\n};\n\nAlertController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: AlertController,\n  factory: function factory(t) {\n    return AlertController.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nAlertController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function AlertController_Factory() {\n    return new AlertController();\n  },\n  token: AlertController,\n  providedIn: \"root\"\n});\n\nvar LoadingController = /*#__PURE__*/function (_OverlayBaseControlle3) {\n  _inherits(LoadingController, _OverlayBaseControlle3);\n\n  var _super8 = _createSuper(LoadingController);\n\n  function LoadingController() {\n    _classCallCheck(this, LoadingController);\n\n    return _super8.call(this, loadingController);\n  }\n\n  return LoadingController;\n}(OverlayBaseController);\n\nLoadingController.ɵfac = function LoadingController_Factory(t) {\n  return new (t || LoadingController)();\n};\n\nLoadingController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: LoadingController,\n  factory: function factory(t) {\n    return LoadingController.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nLoadingController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function LoadingController_Factory() {\n    return new LoadingController();\n  },\n  token: LoadingController,\n  providedIn: \"root\"\n});\n\nvar MenuController = /*#__PURE__*/function () {\n  function MenuController() {\n    _classCallCheck(this, MenuController);\n  }\n\n  _createClass(MenuController, [{\n    key: \"open\",\n    value:\n    /**\n     * Programmatically open the Menu.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu is fully opened\n     */\n    function open(menuId) {\n      return menuController.open(menuId);\n    }\n    /**\n     * Programmatically close the Menu. If no `menuId` is given as the first\n     * argument then it'll close any menu which is open. If a `menuId`\n     * is given then it'll close that exact menu.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu is fully closed\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(menuId) {\n      return menuController.close(menuId);\n    }\n    /**\n     * Toggle the menu. If it's closed, it will open, and if opened, it\n     * will close.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return returns a promise when the menu has been toggled\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle(menuId) {\n      return menuController.toggle(menuId);\n    }\n    /**\n     * Used to enable or disable a menu. For example, there could be multiple\n     * left menus, but only one of them should be able to be opened at the same\n     * time. If there are multiple menus on the same side, then enabling one menu\n     * will also automatically disable all the others that are on the same side.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu, which is useful for chaining.\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable(shouldEnable, menuId) {\n      return menuController.enable(shouldEnable, menuId);\n    }\n    /**\n     * Used to enable or disable the ability to swipe open the menu.\n     * @param shouldEnable  True if it should be swipe-able, false if not.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu, which is useful for chaining.\n     */\n\n  }, {\n    key: \"swipeGesture\",\n    value: function swipeGesture(shouldEnable, menuId) {\n      return menuController.swipeGesture(shouldEnable, menuId);\n    }\n    /**\n     * @param [menuId] Optionally get the menu by its id, or side.\n     * @return Returns true if the specified menu is currently open, otherwise false.\n     * If the menuId is not specified, it returns true if ANY menu is currenly open.\n     */\n\n  }, {\n    key: \"isOpen\",\n    value: function isOpen(menuId) {\n      return menuController.isOpen(menuId);\n    }\n    /**\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns true if the menu is currently enabled, otherwise false.\n     */\n\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled(menuId) {\n      return menuController.isEnabled(menuId);\n    }\n    /**\n     * Used to get a menu instance. If a `menuId` is not provided then it'll\n     * return the first menu found. If a `menuId` is `left` or `right`, then\n     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n     * provided, then it'll try to find the menu using the menu's `id`\n     * property. If a menu is not found then it'll return `null`.\n     * @param [menuId]  Optionally get the menu by its id, or side.\n     * @return Returns the instance of the menu if found, otherwise `null`.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(menuId) {\n      return menuController.get(menuId);\n    }\n    /**\n     * @return Returns the instance of the menu already opened, otherwise `null`.\n     */\n\n  }, {\n    key: \"getOpen\",\n    value: function getOpen() {\n      return menuController.getOpen();\n    }\n    /**\n     * @return Returns an array of all menu instances.\n     */\n\n  }, {\n    key: \"getMenus\",\n    value: function getMenus() {\n      return menuController.getMenus();\n    }\n  }]);\n\n  return MenuController;\n}();\n\nMenuController.ɵfac = function MenuController_Factory(t) {\n  return new (t || MenuController)();\n};\n\nMenuController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: MenuController,\n  factory: function factory(t) {\n    return MenuController.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nMenuController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function MenuController_Factory() {\n    return new MenuController();\n  },\n  token: MenuController,\n  providedIn: \"root\"\n});\n\nvar PickerController = /*#__PURE__*/function (_OverlayBaseControlle4) {\n  _inherits(PickerController, _OverlayBaseControlle4);\n\n  var _super9 = _createSuper(PickerController);\n\n  function PickerController() {\n    _classCallCheck(this, PickerController);\n\n    return _super9.call(this, pickerController);\n  }\n\n  return PickerController;\n}(OverlayBaseController);\n\nPickerController.ɵfac = function PickerController_Factory(t) {\n  return new (t || PickerController)();\n};\n\nPickerController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: PickerController,\n  factory: function factory(t) {\n    return PickerController.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nPickerController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function PickerController_Factory() {\n    return new PickerController();\n  },\n  token: PickerController,\n  providedIn: \"root\"\n});\nvar ModalController = /*#__PURE__*/(function () {\n  var ModalController = /*#__PURE__*/function (_OverlayBaseControlle5) {\n    _inherits(ModalController, _OverlayBaseControlle5);\n\n    var _super10 = _createSuper(ModalController);\n\n    function ModalController(angularDelegate, resolver, injector) {\n      var _this17;\n\n      _classCallCheck(this, ModalController);\n\n      _this17 = _super10.call(this, modalController);\n      _this17.angularDelegate = angularDelegate;\n      _this17.resolver = resolver;\n      _this17.injector = injector;\n      return _this17;\n    }\n\n    _createClass(ModalController, [{\n      key: \"create\",\n      value: function create(opts) {\n        return _get(_getPrototypeOf(ModalController.prototype), \"create\", this).call(this, Object.assign({}, opts, {\n          delegate: this.angularDelegate.create(this.resolver, this.injector)\n        }));\n      }\n    }]);\n\n    return ModalController;\n  }(OverlayBaseController);\n\n  ModalController.ɵfac = function ModalController_Factory(t) {\n    return new (t || ModalController)(ɵngcc0.ɵɵinject(AngularDelegate), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  ModalController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: ModalController,\n    factory: function factory(t) {\n      return ModalController.ɵfac(t);\n    }\n  });\n  return ModalController;\n})();\nvar PopoverController = /*#__PURE__*/(function () {\n  var PopoverController = /*#__PURE__*/function (_OverlayBaseControlle6) {\n    _inherits(PopoverController, _OverlayBaseControlle6);\n\n    var _super11 = _createSuper(PopoverController);\n\n    function PopoverController(angularDelegate, resolver, injector) {\n      var _this18;\n\n      _classCallCheck(this, PopoverController);\n\n      _this18 = _super11.call(this, popoverController);\n      _this18.angularDelegate = angularDelegate;\n      _this18.resolver = resolver;\n      _this18.injector = injector;\n      return _this18;\n    }\n\n    _createClass(PopoverController, [{\n      key: \"create\",\n      value: function create(opts) {\n        return _get(_getPrototypeOf(PopoverController.prototype), \"create\", this).call(this, Object.assign({}, opts, {\n          delegate: this.angularDelegate.create(this.resolver, this.injector)\n        }));\n      }\n    }]);\n\n    return PopoverController;\n  }(OverlayBaseController);\n\n  PopoverController.ɵfac = function PopoverController_Factory(t) {\n    return new (t || PopoverController)(ɵngcc0.ɵɵinject(AngularDelegate), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  PopoverController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: PopoverController,\n    factory: function factory(t) {\n      return PopoverController.ɵfac(t);\n    }\n  });\n  return PopoverController;\n})();\n\nvar ToastController = /*#__PURE__*/function (_OverlayBaseControlle7) {\n  _inherits(ToastController, _OverlayBaseControlle7);\n\n  var _super12 = _createSuper(ToastController);\n\n  function ToastController() {\n    _classCallCheck(this, ToastController);\n\n    return _super12.call(this, toastController);\n  }\n\n  return ToastController;\n}(OverlayBaseController);\n\nToastController.ɵfac = function ToastController_Factory(t) {\n  return new (t || ToastController)();\n};\n\nToastController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: ToastController,\n  factory: function factory(t) {\n    return ToastController.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nToastController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function ToastController_Factory() {\n    return new ToastController();\n  },\n  token: ToastController,\n  providedIn: \"root\"\n});\n\nvar DomController = /*#__PURE__*/function () {\n  function DomController() {\n    _classCallCheck(this, DomController);\n  }\n\n  _createClass(DomController, [{\n    key: \"read\",\n    value:\n    /**\n     * Schedules a task to run during the READ phase of the next frame.\n     * This task should only read the DOM, but never modify it.\n     */\n    function read(cb) {\n      getQueue().read(cb);\n    }\n    /**\n     * Schedules a task to run during the WRITE phase of the next frame.\n     * This task should write the DOM, but never READ it.\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(cb) {\n      getQueue().write(cb);\n    }\n  }]);\n\n  return DomController;\n}();\n\nDomController.ɵfac = function DomController_Factory(t) {\n  return new (t || DomController)();\n};\n\nDomController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: DomController,\n  factory: function factory(t) {\n    return DomController.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nDomController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function DomController_Factory() {\n    return new DomController();\n  },\n  token: DomController,\n  providedIn: \"root\"\n});\n\nvar getQueue = function getQueue() {\n  var win = typeof window !== 'undefined' ? window : null;\n\n  if (win != null) {\n    var Ionic = win.Ionic;\n\n    if (Ionic && Ionic.queue) {\n      return Ionic.queue;\n    }\n\n    return {\n      read: function read(cb) {\n        return win.requestAnimationFrame(cb);\n      },\n      write: function write(cb) {\n        return win.requestAnimationFrame(cb);\n      }\n    };\n  }\n\n  return {\n    read: function read(cb) {\n      return cb();\n    },\n    write: function write(cb) {\n      return cb();\n    }\n  };\n};\n\nvar ɵ0$8 = getQueue;\n\nvar AnimationController = /*#__PURE__*/function () {\n  function AnimationController() {\n    _classCallCheck(this, AnimationController);\n  }\n\n  _createClass(AnimationController, [{\n    key: \"create\",\n    value:\n    /**\n     * Create a new animation\n     */\n    function create(animationId) {\n      return createAnimation(animationId);\n    }\n    /**\n     * EXPERIMENTAL\n     *\n     * Given a progression and a cubic bezier function,\n     * this utility returns the time value(s) at which the\n     * cubic bezier reaches the given time progression.\n     *\n     * If the cubic bezier never reaches the progression\n     * the result will be an empty array.\n     *\n     * This is most useful for switching between easing curves\n     * when doing a gesture animation (i.e. going from linear easing\n     * during a drag, to another easing when `progressEnd` is called)\n     */\n\n  }, {\n    key: \"easingTime\",\n    value: function easingTime(p0, p1, p2, p3, progression) {\n      return getTimeGivenProgression(p0, p1, p2, p3, progression);\n    }\n  }]);\n\n  return AnimationController;\n}();\n\nAnimationController.ɵfac = function AnimationController_Factory(t) {\n  return new (t || AnimationController)();\n};\n\nAnimationController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: AnimationController,\n  factory: function factory(t) {\n    return AnimationController.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nAnimationController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function AnimationController_Factory() {\n    return new AnimationController();\n  },\n  token: AnimationController,\n  providedIn: \"root\"\n});\n\nvar GestureController = /*#__PURE__*/function () {\n  function GestureController(zone) {\n    _classCallCheck(this, GestureController);\n\n    this.zone = zone;\n  }\n  /**\n   * Create a new gesture\n   */\n\n\n  _createClass(GestureController, [{\n    key: \"create\",\n    value: function create(opts) {\n      var _this19 = this;\n\n      var runInsideAngularZone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (runInsideAngularZone) {\n        Object.getOwnPropertyNames(opts).forEach(function (key) {\n          if (typeof opts[key] === 'function') {\n            var fn = opts[key];\n\n            opts[key] = function () {\n              for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n                props[_key] = arguments[_key];\n              }\n\n              return _this19.zone.run(function () {\n                return fn.apply(void 0, props);\n              });\n            };\n          }\n        });\n      }\n\n      return createGesture(opts);\n    }\n  }]);\n\n  return GestureController;\n}();\n\nGestureController.ɵfac = function GestureController_Factory(t) {\n  return new (t || GestureController)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n};\n\nGestureController.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: GestureController,\n  factory: function factory(t) {\n    return GestureController.ɵfac(t);\n  },\n  providedIn: 'root'\n});\nGestureController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function GestureController_Factory() {\n    return new GestureController(ɵɵinject(NgZone));\n  },\n  token: GestureController,\n  providedIn: \"root\"\n});\n\nvar IonicRouteStrategy = /*#__PURE__*/function () {\n  function IonicRouteStrategy() {\n    _classCallCheck(this, IonicRouteStrategy);\n  }\n\n  _createClass(IonicRouteStrategy, [{\n    key: \"shouldDetach\",\n    value: function shouldDetach(_route) {\n      return false;\n    }\n  }, {\n    key: \"shouldAttach\",\n    value: function shouldAttach(_route) {\n      return false;\n    }\n  }, {\n    key: \"store\",\n    value: function store(_route, _detachedTree) {\n      return;\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(_route) {\n      return null;\n    }\n  }, {\n    key: \"shouldReuseRoute\",\n    value: function shouldReuseRoute(future, curr) {\n      if (future.routeConfig !== curr.routeConfig) {\n        return false;\n      } // checking router params\n\n\n      var futureParams = future.params;\n      var currentParams = curr.params;\n      var keysA = Object.keys(futureParams);\n      var keysB = Object.keys(currentParams);\n\n      if (keysA.length !== keysB.length) {\n        return false;\n      } // Test for A's keys different from B.\n\n\n      for (var _i = 0, _keysA = keysA; _i < _keysA.length; _i++) {\n        var key = _keysA[_i];\n\n        if (currentParams[key] !== futureParams[key]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return IonicRouteStrategy;\n}();\n\nvar appInitialize = function appInitialize(config, doc, zone) {\n  return function () {\n    var win = doc.defaultView;\n\n    if (win && typeof window !== 'undefined') {\n      setupConfig(Object.assign({}, config, {\n        _zoneGate: function _zoneGate(h) {\n          return zone.run(h);\n        }\n      }));\n      var aelFn = '__zone_symbol__addEventListener' in doc.body ? '__zone_symbol__addEventListener' : 'addEventListener';\n      return applyPolyfills().then(function () {\n        return defineCustomElements(win, {\n          exclude: ['ion-tabs', 'ion-tab'],\n          syncQueue: true,\n          raf: raf,\n          jmp: function jmp(h) {\n            return zone.runOutsideAngular(h);\n          },\n          ael: function ael(elm, eventName, cb, opts) {\n            elm[aelFn](eventName, cb, opts);\n          },\n          rel: function rel(elm, eventName, cb, opts) {\n            elm.removeEventListener(eventName, cb, opts);\n          }\n        });\n      });\n    }\n  };\n};\n\nvar IonicModule_1;\nvar DECLARATIONS = [// proxies\nIonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonText, IonTextarea, IonThumbnail, IonToggle, IonToolbar, IonTitle, IonTabs, // ngModel accessors\nBooleanValueAccessor, NumericValueAccessor, RadioValueAccessor, SelectValueAccessor, TextValueAccessor, // navigation\nIonRouterOutlet, IonBackButtonDelegate, NavDelegate, RouterLinkDelegate, // virtual scroll\nVirtualFooter, VirtualHeader, VirtualItem, IonVirtualScroll];\n\nvar IonicModule = IonicModule_1 = /*#__PURE__*/function () {\n  function IonicModule() {\n    _classCallCheck(this, IonicModule);\n  }\n\n  _createClass(IonicModule, null, [{\n    key: \"forRoot\",\n    value: function forRoot(config) {\n      return {\n        ngModule: IonicModule_1,\n        providers: [{\n          provide: ConfigToken,\n          useValue: config\n        }, {\n          provide: APP_INITIALIZER,\n          useFactory: appInitialize,\n          multi: true,\n          deps: [ConfigToken, DOCUMENT, NgZone]\n        }]\n      };\n    }\n  }]);\n\n  return IonicModule;\n}();\n\nIonicModule.ɵfac = function IonicModule_Factory(t) {\n  return new (t || IonicModule)();\n};\n\nIonicModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: IonicModule\n});\nIonicModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  providers: [AngularDelegate, ModalController, PopoverController],\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IonicModule, {\n    declarations: function declarations() {\n      return [IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonText, IonTextarea, IonThumbnail, IonToggle, IonToolbar, IonTitle, IonTabs, BooleanValueAccessor, NumericValueAccessor, RadioValueAccessor, SelectValueAccessor, TextValueAccessor, IonRouterOutlet, IonBackButtonDelegate, NavDelegate, RouterLinkDelegate, VirtualFooter, VirtualHeader, VirtualItem, IonVirtualScroll];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonText, IonTextarea, IonThumbnail, IonToggle, IonToolbar, IonTitle, IonTabs, BooleanValueAccessor, NumericValueAccessor, RadioValueAccessor, SelectValueAccessor, TextValueAccessor, IonRouterOutlet, IonBackButtonDelegate, NavDelegate, RouterLinkDelegate, VirtualFooter, VirtualHeader, VirtualItem, IonVirtualScroll];\n    }\n  });\n})(); // DIRECTIVES\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ActionSheetController, AlertController, AngularDelegate, AnimationController, BooleanValueAccessor, Config, DomController, GestureController, IonApp, IonAvatar, IonBackButton, IonBackButtonDelegate, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToggle, IonToolbar, IonVirtualScroll, IonicModule, IonicRouteStrategy, LoadingController, MenuController, ModalController, NavController, NavDelegate, NavParams, NumericValueAccessor, PickerController, Platform, PopoverController, RadioValueAccessor, RouterLinkDelegate, SelectValueAccessor, TextValueAccessor, ToastController, VirtualFooter, VirtualHeader, VirtualItem, ConfigToken as ɵa, ValueAccessor as ɵb, ProxyCmp as ɵc, OverlayBaseController as ɵe, appInitialize as ɵf }; //# sourceMappingURL=ionic-angular.js.map","map":null,"metadata":{},"sourceType":"module"}